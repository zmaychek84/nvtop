{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "glog-e83e50ed-d054-48bc-b219-1d3324cdd8d7",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Use of Prohibited C Function (strncpy)\" vulnerability arises when the `strncpy` function is used improperly in C++ programming. `strncpy` is often used to copy strings with a specified maximum length to prevent buffer overflows. However, it can lead to vulnerabilities if not used carefully, as it does not guarantee null-termination of the destination string if the source string is longer than the specified length. This can result in undefined behavior, including buffer overflows, data corruption, or security vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using safer string handling functions like `strlcpy` or `snprintf` that ensure null-termination.\n2. **Manual Null-Termination**: Always manually null-terminate the destination buffer after using `strncpy`.\n3. **Bounds Checking**: Ensure that the size of the destination buffer is sufficient to hold the source string plus the null terminator.\n4. **Static Analysis Tools**: Use static analysis tools to detect and fix unsafe string operations in the codebase.\n\n### Source Code Fix Recommendation\n\nReplace the use of `strncpy` with a safer alternative or ensure proper null-termination:\n\n```cpp\n#include <cstring> // Required for strlcpy\n\n// Assuming strlcpy is available, otherwise implement a custom version\nsize_t strlcpy(char *dst, const char *src, size_t size) {\n    size_t src_len = std::strlen(src);\n    if (size > 0) {\n        size_t copy_len = (src_len >= size) ? size - 1 : src_len;\n        std::memcpy(dst, src, copy_len);\n        dst[copy_len] = '\\0';\n    }\n    return src_len;\n}\n\n// Fix for the specific vulnerability sink\nstrlcpy(static_info->device_name, name, sizeof(static_info->device_name));\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library dependencies are required:\n\n- `<cstring>`: For string manipulation functions like `strlcpy` and `std::memcpy`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-ccf1b73a-1cdf-4e92-894f-5d3a41dedaf8",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Use of Prohibited C Function (strncpy)\" vulnerability arises when the `strncpy` function is used improperly in C++ programming. `strncpy` is often used to copy strings with a specified maximum length to prevent buffer overflows. However, it can lead to vulnerabilities if not used carefully, as it does not guarantee null-termination of the destination string if the source string is longer than the specified length. This can result in undefined behavior, including buffer overflows, data corruption, or security vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using safer string handling functions like `strlcpy` or `snprintf` that ensure null-termination.\n2. **Manual Null-Termination**: Always manually null-terminate the destination buffer after using `strncpy`.\n3. **Bounds Checking**: Ensure that the size of the destination buffer is sufficient to hold the source string plus the null terminator.\n4. **Static Analysis Tools**: Use static analysis tools to detect and fix unsafe string operations in the codebase.\n\n### Source Code Fix Recommendation\n\nReplace the use of `strncpy` with a safer alternative or ensure proper null-termination:\n\n```cpp\n#include <cstring> // Required for strlcpy\n\n// Assuming strlcpy is available, otherwise implement a custom version\nsize_t strlcpy(char *dst, const char *src, size_t size) {\n    size_t src_len = std::strlen(src);\n    if (size > 0) {\n        size_t copy_len = (src_len >= size) ? size - 1 : src_len;\n        std::memcpy(dst, src, copy_len);\n        dst[copy_len] = '\\0';\n    }\n    return src_len;\n}\n\n// Fix for the specific vulnerability sink\nstrlcpy(static_info->device_name, name, sizeof(static_info->device_name));\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library dependencies are required:\n\n- `<cstring>`: For string manipulation functions like `strlcpy` and `std::memcpy`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-e7857526-e73f-41b9-a12b-113236898c89",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the use of the `strlen` function in C++ arises when the function is used without proper validation of the input data. The `strlen` function calculates the length of a C-style string by searching for the null terminator (`'\\0'`). If the input string is not properly null-terminated or if it points to an invalid memory location, this can lead to undefined behavior, including buffer overflows, crashes, or information leaks.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that all input strings are properly null-terminated before passing them to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that automatically manage string lengths and memory, such as `std::string` in C++.\n3. **Bounds Checking**: Implement bounds checking to ensure that the input data does not exceed expected limits.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential vulnerabilities in the code.\n\n### Source Code Fix Recommendation\n\nTo mitigate the vulnerability associated with `strlen(legend[i])`, consider the following code fix:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <vector>\n\n// Example function that uses std::string instead of C-style strings\nvoid processLegend(const std::vector<std::string>& legend) {\n    for (size_t i = 0; i < legend.size(); ++i) {\n        // Using std::string::length() which is safer\n        size_t length = legend[i].length();\n        std::cout << \"Length of legend[\" << i << \"]: \" << length << std::endl;\n    }\n}\n\nint main() {\n    std::vector<std::string> legend = {\"example1\", \"example2\", \"example3\"};\n    processLegend(legend);\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following standard C++ libraries are required:\n\n- `<iostream>`: For input and output stream operations.\n- `<string>`: For using the `std::string` class.\n- `<vector>`: For using the `std::vector` container.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/): A list of the top ten most critical web application security risks.\n- [Common Weakness Enumeration (CWE-120)](https://cwe.mitre.org/data/definitions/120.html): Classic Buffer Overflow.\n\nThese links are verified to be active and accessible to anonymous users."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-97f30f23-a251-4f4c-9edf-e8b01e92989c",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Use of Prohibited C Function (strncpy)\" vulnerability arises when the `strncpy` function is used improperly in C++ programming. `strncpy` is often used to copy strings with a specified maximum length to prevent buffer overflows. However, it can lead to vulnerabilities if not used carefully, as it does not guarantee null-termination of the destination string if the source string is longer than the specified length. This can result in undefined behavior, including buffer overflows, data corruption, or security vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using safer string handling functions like `strlcpy` or `snprintf` that ensure null-termination.\n2. **Manual Null-Termination**: Always manually null-terminate the destination buffer after using `strncpy`.\n3. **Bounds Checking**: Ensure that the size of the destination buffer is sufficient to hold the source string plus the null terminator.\n4. **Static Analysis Tools**: Use static analysis tools to detect and fix unsafe string operations in the codebase.\n\n### Source Code Fix Recommendation\n\nReplace the use of `strncpy` with a safer alternative or ensure proper null-termination:\n\n```cpp\n#include <cstring> // Required for strlcpy\n\n// Assuming strlcpy is available, otherwise implement a custom version\nsize_t strlcpy(char *dst, const char *src, size_t size) {\n    size_t src_len = std::strlen(src);\n    if (size > 0) {\n        size_t copy_len = (src_len >= size) ? size - 1 : src_len;\n        std::memcpy(dst, src, copy_len);\n        dst[copy_len] = '\\0';\n    }\n    return src_len;\n}\n\n// Fix for the specific vulnerability sink\nstrlcpy(static_info->device_name, name, sizeof(static_info->device_name));\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library dependencies are required:\n\n- `<cstring>`: For string manipulation functions like `strlcpy` and `std::memcpy`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-8f06b672-563b-4b7e-95a8-adbe198051db",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the use of the `strlen` function in C++ arises when it is used on untrusted or improperly validated input. The `strlen` function calculates the length of a string by searching for the null terminator (`\\0`). If the input is not properly null-terminated or if it is manipulated by an attacker, it can lead to buffer overflows, reading out of bounds, or other undefined behaviors. This can result in security vulnerabilities such as information disclosure, application crashes, or even arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate input to ensure it is properly null-terminated and within expected size limits.\n2. **Use Safer Alternatives**: Consider using safer string handling functions like `strnlen` or C++ standard library functions like `std::string` which manage string lengths internally.\n3. **Bounds Checking**: Ensure that any buffer operations are bounded and that buffers are properly sized to handle expected input sizes.\n4. **Memory Management**: Use smart pointers or other memory management techniques to avoid manual memory handling errors.\n\n### Source Code Fix Recommendation\n\nIf you have a code snippet like:\n\n```cpp\nsize_t length = strlen(messages[i]);\n```\n\nYou can replace it with:\n\n```cpp\n#include <cstring> // Required for strnlen\n\n// Assuming MAX_LENGTH is the maximum expected length of the message\nconst size_t MAX_LENGTH = 1024;\nsize_t length = strnlen(messages[i], MAX_LENGTH);\n```\n\nOr, if using C++ standard library:\n\n```cpp\n#include <string>\n\nstd::string message = messages[i];\nsize_t length = message.length();\n```\n\n### Library Dependencies\n\nFor the above code examples, the following libraries are required:\n\n- `<cstring>`: Required for `strnlen`.\n- `<string>`: Required for `std::string`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-01e52bba-084b-4af7-9b2d-fd27924c199a",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the use of the `strlen` function in C++ arises when it is used on untrusted or improperly validated input. The `strlen` function calculates the length of a string by searching for the null terminator (`\\0`). If the input is not properly null-terminated or if it is manipulated by an attacker, it can lead to buffer overflows, reading out of bounds, or other undefined behaviors. This can result in security vulnerabilities such as information disclosure, application crashes, or even arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate input to ensure it is properly null-terminated and within expected size limits.\n2. **Use Safer Alternatives**: Consider using safer string handling functions like `strnlen` or C++ standard library functions like `std::string` which manage string lengths internally.\n3. **Bounds Checking**: Ensure that any buffer operations are bounded and that buffers are properly sized to handle expected input sizes.\n4. **Memory Management**: Use smart pointers or other memory management techniques to avoid manual memory handling errors.\n\n### Source Code Fix Recommendation\n\nIf you have a code snippet like:\n\n```cpp\nsize_t length = strlen(messages[i]);\n```\n\nYou can replace it with:\n\n```cpp\n#include <cstring> // Required for strnlen\n\n// Assuming MAX_LENGTH is the maximum expected length of the message\nconst size_t MAX_LENGTH = 1024;\nsize_t length = strnlen(messages[i], MAX_LENGTH);\n```\n\nOr, if using C++ standard library:\n\n```cpp\n#include <string>\n\nstd::string message = messages[i];\nsize_t length = message.length();\n```\n\n### Library Dependencies\n\nFor the above code examples, the following libraries are required:\n\n- `<cstring>`: Required for `strnlen`.\n- `<string>`: Required for `std::string`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-5b636645-750a-4db0-a28a-9b00b63a2aaa",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the use of the `strlen` function in C++ arises when it is used on untrusted or improperly validated input. The `strlen` function calculates the length of a string by searching for the null terminator (`\\0`). If the input is not properly null-terminated or if it is manipulated by an attacker, it can lead to buffer overflows, reading out of bounds, or other undefined behaviors. This can result in security vulnerabilities such as information disclosure, application crashes, or even arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate input to ensure it is properly null-terminated and within expected size limits.\n2. **Use Safer Alternatives**: Consider using safer string handling functions like `strnlen` or C++ standard library functions like `std::string` which manage string lengths internally.\n3. **Bounds Checking**: Ensure that any buffer operations are bounded and that buffers are properly sized to handle expected input sizes.\n4. **Memory Management**: Use smart pointers or other memory management techniques to avoid manual memory handling errors.\n\n### Source Code Fix Recommendation\n\nIf you have a code snippet like:\n\n```cpp\nsize_t length = strlen(messages[i]);\n```\n\nYou can replace it with:\n\n```cpp\n#include <cstring> // Required for strnlen\n\n// Assuming MAX_LENGTH is the maximum expected length of the message\nconst size_t MAX_LENGTH = 1024;\nsize_t length = strnlen(messages[i], MAX_LENGTH);\n```\n\nOr, if using C++ standard library:\n\n```cpp\n#include <string>\n\nstd::string message = messages[i];\nsize_t length = message.length();\n```\n\n### Library Dependencies\n\nFor the above code examples, the following libraries are required:\n\n- `<cstring>`: Required for `strnlen`.\n- `<string>`: Required for `std::string`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-bc541c0e-709a-41ac-8007-9522e9a4b4d7",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the use of the `strlen` function in C++ arises when it is used on a potentially uninitialized or non-null-terminated string. This can lead to undefined behavior, including reading beyond the buffer's bounds, which can cause crashes or expose sensitive data. In the context of `strlen(gpuinfo->static_info.device_name)`, if `device_name` is not properly null-terminated, `strlen` will continue reading memory until it encounters a null byte, which can lead to a buffer over-read.\n\n### General Mitigation Advice\n\n1. **Ensure Proper Initialization**: Always initialize strings and ensure they are null-terminated.\n2. **Use Safer Alternatives**: Consider using safer string handling functions that limit the number of characters read, such as `strnlen`.\n3. **Input Validation**: Validate and sanitize all inputs to ensure they conform to expected formats and lengths.\n4. **Bounds Checking**: Implement bounds checking to ensure that operations do not exceed buffer limits.\n\n### Source Code Fix Recommendation\n\nTo mitigate the vulnerability, replace `strlen` with `strnlen`, specifying a maximum length to prevent reading beyond the buffer:\n\n```cpp\n#include <cstring> // Required for strnlen\n\n// Assuming MAX_DEVICE_NAME_LENGTH is the maximum expected length of device_name\nsize_t device_name_length = strnlen(gpuinfo->static_info.device_name, MAX_DEVICE_NAME_LENGTH);\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library dependencies are required:\n\n- `<cstring>`: This header is required for using `strnlen`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-3d3b261e-b9ce-41a4-96ad-1fb09536485e",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the use of the `strlen` function in C++ arises when the function is called on a pointer that may not be null-terminated or may not point to a valid string. This can lead to undefined behavior, including buffer overflows, if the function reads beyond the intended memory bounds. In the specific case of `strlen(all_procs.processes[i].process->user_name)`, if `user_name` is not properly null-terminated or is not a valid string, it can cause the program to crash or expose sensitive data.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that all input strings are properly validated and null-terminated before being passed to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions that limit the number of characters read, such as `strnlen`.\n3. **Memory Management**: Ensure that memory allocations for strings are sufficient to include the null terminator.\n4. **Code Review and Testing**: Regularly review code and perform thorough testing to identify and fix potential vulnerabilities.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risk associated with the use of `strlen`, you can replace it with `strnlen`, specifying a maximum length to prevent reading beyond the buffer:\n\n```cpp\n#include <cstring> // Required for strnlen\n\n// Assuming MAX_USER_NAME_LENGTH is defined as the maximum expected length of user_name\nsize_t length = strnlen(all_procs.processes[i].process->user_name, MAX_USER_NAME_LENGTH);\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library dependency is required:\n\n- `<cstring>`: This library is required for using `strnlen`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-767d9983-8224-4723-9f2f-c30796e215c9",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ typically arises from improper use of the `malloc` function, which is used to allocate memory dynamically. This can lead to several issues, such as buffer overflows, memory leaks, or undefined behavior if the allocated memory is not managed correctly. In the provided code snippet, the vulnerability may occur if `total_processes_count` is not properly validated, leading to an incorrect amount of memory being allocated.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that `total_processes_count` is validated to be a positive integer and within a reasonable range before using it in `malloc`.\n2. **Check for NULL**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Use `calloc`**: Consider using `calloc` instead of `malloc` as it initializes the allocated memory to zero, which can help prevent certain types of vulnerabilities.\n4. **Free Memory**: Ensure that all dynamically allocated memory is properly freed when no longer needed to prevent memory leaks.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstdlib> // for malloc and free\n\nstruct Process {\n    // Define the structure of a process\n};\n\nstruct MergedDevicesProcesses {\n    Process* processes;\n};\n\nint main() {\n    size_t total_processes_count = 10; // Example value, should be validated\n    MergedDevicesProcesses merged_devices_processes;\n\n    // Validate total_processes_count\n    if (total_processes_count <= 0) {\n        std::cerr << \"Invalid process count\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    // Allocate memory safely\n    merged_devices_processes.processes = static_cast<Process*>(malloc(total_processes_count * sizeof(Process)));\n    if (merged_devices_processes.processes == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    // Use the allocated memory\n    // ...\n\n    // Free the allocated memory\n    free(merged_devices_processes.processes);\n\n    return EXIT_SUCCESS;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<cstdlib>`: For `malloc` and `free` functions.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-1b55f86a-7195-4fbd-aee3-1415268a9140",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises when the function is used without proper validation of the input string. The `strlen` function calculates the length of a string by searching for the null terminator (`'\\0'`). If the input string is not properly null-terminated or if it points to an invalid memory location, this can lead to undefined behavior, including buffer overflows, crashes, or information leaks.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that all input strings are properly null-terminated before passing them to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that automatically manage string lengths and memory, such as `std::string` in C++.\n3. **Bounds Checking**: Implement bounds checking to ensure that the input string does not exceed expected limits.\n4. **Memory Management**: Properly manage memory to avoid dangling pointers or accessing uninitialized memory.\n\n### Source Code Fix Recommendation\n\nTo mitigate the vulnerability when using `strlen`, ensure that the input string is properly null-terminated and within a valid memory range. Consider using `std::string` for safer string handling.\n\n```cpp\n#include <iostream>\n#include <string>\n\nint main() {\n    std::string prelude = \"Hello, World!\";\n    size_t length = prelude.length(); // Use std::string's length method\n    std::cout << \"Length of the string: \" << length << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following standard library dependencies are required:\n\n- `<iostream>`: For input and output stream operations.\n- `<string>`: For using the `std::string` class.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n\nThese links have been verified to be active and accessible for anonymous users."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-a8eb351d-3c35-4b1b-b4ac-8970a5562d17",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises when the function is used without proper validation of the input string. If `strlen` is called on a string that is not null-terminated, it can lead to undefined behavior, including buffer overflows, which can be exploited by attackers to execute arbitrary code or cause a denial of service.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate input strings to ensure they are null-terminated before passing them to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions like `strnlen` which allows specifying a maximum length to prevent reading beyond the buffer.\n3. **Memory Management**: Ensure proper memory allocation and deallocation to avoid buffer overflows and memory leaks.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential vulnerabilities in the code.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstring> // Required for strlen\n#include <iostream> // Required for std::cout\n\nvoid processString(const char* input) {\n    if (input == nullptr) {\n        std::cerr << \"Error: Null input string\" << std::endl;\n        return;\n    }\n\n    // Use strnlen to limit the length to a safe maximum\n    size_t maxLength = 1024; // Define a reasonable maximum length\n    size_t length = strnlen(input, maxLength);\n\n    if (length == maxLength) {\n        std::cerr << \"Error: Input string is too long or not null-terminated\" << std::endl;\n        return;\n    }\n\n    // Safe to use length now\n    std::cout << \"String length: \" << length << std::endl;\n}\n\nint main() {\n    const char* inside_braces_right = \"Example string\";\n    processString(inside_braces_right);\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for `strlen` and `strnlen`.\n- `<iostream>`: Required for input/output operations.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-88694392-9b5f-4b0a-bd8e-5c7ba8373f68",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Identified Issue with C Function (malloc)\" vulnerability in C++ arises when dynamic memory allocation is improperly handled, leading to potential security risks such as buffer overflows, memory leaks, or undefined behavior. In the provided code snippet, the use of `malloc` to allocate memory for `interface->plots` is susceptible to integer overflow if `interface->num_plots` is excessively large. This can result in insufficient memory allocation, leading to potential overwrites of adjacent memory.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that `interface->num_plots` is within a reasonable range before performing the allocation.\n2. **Use Safer Functions**: Consider using safer alternatives like `calloc`, which initializes the allocated memory to zero, or C++ constructs like `std::vector` that manage memory automatically.\n3. **Check for Overflow**: Before allocation, check if the multiplication of `interface->num_plots` and `sizeof(*interface->plots)` would overflow.\n4. **Error Handling**: Always check the return value of `malloc` to ensure that the memory allocation was successful.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <limits>\n#include <cstdlib>\n\nstruct Interface {\n    size_t num_plots;\n    void* plots;\n};\n\nbool is_multiplication_safe(size_t a, size_t b) {\n    return a == 0 || b <= std::numeric_limits<size_t>::max() / a;\n}\n\nvoid allocate_plots(Interface* interface) {\n    if (!is_multiplication_safe(interface->num_plots, sizeof(*interface->plots))) {\n        std::cerr << \"Integer overflow detected during memory allocation.\" << std::endl;\n        return;\n    }\n\n    interface->plots = malloc(interface->num_plots * sizeof(*interface->plots));\n    if (interface->plots == nullptr) {\n        std::cerr << \"Memory allocation failed.\" << std::endl;\n        // Handle allocation failure\n    }\n}\n\nint main() {\n    Interface interface;\n    interface.num_plots = 100; // Example value\n    allocate_plots(&interface);\n\n    // Use the allocated memory\n\n    free(interface.plots); // Don't forget to free the allocated memory\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<limits>`: To access numeric limits for data types.\n- `<cstdlib>`: For memory allocation functions like `malloc` and `free`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-5ccfb32c-adff-43dc-a729-e01944c68a9f",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises from its inability to handle non-null-terminated strings. If `strlen` is called on a string that is not properly null-terminated, it can lead to undefined behavior, including reading beyond the buffer's bounds, which can cause crashes or expose sensitive data. This is a common issue in C/C++ programming due to the manual management of string termination.\n\n### General Mitigation Advice\n\n1. **Ensure Proper Null-Termination**: Always ensure that strings are null-terminated before passing them to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or classes, such as `std::string` in C++, which manage null-termination automatically.\n3. **Bounds Checking**: Implement bounds checking to ensure that operations on strings do not exceed their allocated memory.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstring> // Required for strlen\n#include <string>  // Required for std::string\n\nvoid safePrint(const char* toPrint) {\n    if (toPrint == nullptr) {\n        std::cerr << \"Error: Null pointer received.\" << std::endl;\n        return;\n    }\n\n    // Use std::string to ensure null-termination\n    std::string safeString(toPrint);\n    std::cout << \"String length: \" << safeString.length() << std::endl;\n    std::cout << \"String content: \" << safeString << std::endl;\n}\n\nint main() {\n    const char* myString = \"Hello, World!\";\n    safePrint(myString);\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output stream operations.\n- `<cstring>`: For C-style string operations, including `strlen`.\n- `<string>`: For using `std::string`, which provides safer string handling.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-170: Improper Null Termination](https://cwe.mitre.org/data/definitions/170.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-2b40fd04-5776-4f3c-8c36-64bfa8e2a3c1",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises from its inability to handle non-null-terminated strings. If `strlen` is called on a string that is not properly null-terminated, it can lead to undefined behavior, including reading beyond the buffer's bounds, which can cause crashes or expose sensitive data. This is a common issue in C/C++ programming due to the manual management of string termination.\n\n### General Mitigation Advice\n\n1. **Ensure Proper Null-Termination**: Always ensure that strings are null-terminated before passing them to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or classes, such as `std::string` in C++, which manage null-termination automatically.\n3. **Bounds Checking**: Implement bounds checking to ensure that operations on strings do not exceed their allocated memory.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstring> // Required for strlen\n#include <string>  // Required for std::string\n\nvoid safePrint(const char* toPrint) {\n    if (toPrint == nullptr) {\n        std::cerr << \"Error: Null pointer received.\" << std::endl;\n        return;\n    }\n\n    // Use std::string to ensure null-termination\n    std::string safeString(toPrint);\n    std::cout << \"String length: \" << safeString.length() << std::endl;\n    std::cout << \"String content: \" << safeString << std::endl;\n}\n\nint main() {\n    const char* myString = \"Hello, World!\";\n    safePrint(myString);\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output stream operations.\n- `<cstring>`: For C-style string operations, including `strlen`.\n- `<string>`: For using `std::string`, which provides safer string handling.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-170: Improper Null Termination](https://cwe.mitre.org/data/definitions/170.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-a67a8db3-e450-4d14-b349-065eb5ccb849",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises from its inability to handle non-null-terminated strings. If `strlen` is called on a string that is not properly null-terminated, it can lead to undefined behavior, including reading beyond the buffer's bounds, which can cause crashes or expose sensitive data. This is a common issue in C/C++ programming due to the manual management of string termination.\n\n### General Mitigation Advice\n\n1. **Ensure Proper Null-Termination**: Always ensure that strings are null-terminated before passing them to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or classes, such as `std::string` in C++, which manage null-termination automatically.\n3. **Bounds Checking**: Implement bounds checking to ensure that operations on strings do not exceed their allocated memory.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstring> // Required for strlen\n#include <string>  // Required for std::string\n\nvoid safePrint(const char* toPrint) {\n    if (toPrint == nullptr) {\n        std::cerr << \"Error: Null pointer received.\" << std::endl;\n        return;\n    }\n\n    // Use std::string to ensure null-termination\n    std::string safeString(toPrint);\n    std::cout << \"String length: \" << safeString.length() << std::endl;\n    std::cout << \"String content: \" << safeString << std::endl;\n}\n\nint main() {\n    const char* myString = \"Hello, World!\";\n    safePrint(myString);\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output stream operations.\n- `<cstring>`: For C-style string operations, including `strlen`.\n- `<string>`: For using `std::string`, which provides safer string handling.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-170: Improper Null Termination](https://cwe.mitre.org/data/definitions/170.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-6a465949-789b-4b54-80d5-580a8ad6dc7b",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises from its inability to handle non-null-terminated strings. If `strlen` is called on a string that is not properly null-terminated, it can lead to undefined behavior, including reading beyond the buffer's bounds, which can cause crashes or expose sensitive data. This is a common issue in C/C++ programming due to the manual management of string termination.\n\n### General Mitigation Advice\n\n1. **Ensure Proper Null-Termination**: Always ensure that strings are null-terminated before passing them to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or classes, such as `std::string` in C++, which manage null-termination automatically.\n3. **Bounds Checking**: Implement bounds checking to ensure that operations on strings do not exceed their allocated memory.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstring> // Required for strlen\n#include <string>  // Required for std::string\n\nvoid safePrint(const char* toPrint) {\n    if (toPrint == nullptr) {\n        std::cerr << \"Error: Null pointer received.\" << std::endl;\n        return;\n    }\n\n    // Use std::string to ensure null-termination\n    std::string safeString(toPrint);\n    std::cout << \"String length: \" << safeString.length() << std::endl;\n    std::cout << \"String content: \" << safeString << std::endl;\n}\n\nint main() {\n    const char* myString = \"Hello, World!\";\n    safePrint(myString);\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output stream operations.\n- `<cstring>`: For C-style string operations, including `strlen`.\n- `<string>`: For using `std::string`, which provides safer string handling.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-170: Improper Null Termination](https://cwe.mitre.org/data/definitions/170.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-39737e0c-9e3d-428a-8bb0-eabf377ca11c",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises from its inability to handle non-null-terminated strings. If `strlen` is called on a string that is not properly null-terminated, it can lead to undefined behavior, including reading beyond the buffer's bounds, which can cause crashes or expose sensitive data. This is a common issue in C/C++ programming due to the manual management of string termination.\n\n### General Mitigation Advice\n\n1. **Ensure Proper Null-Termination**: Always ensure that strings are null-terminated before passing them to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or classes, such as `std::string` in C++, which manage null-termination automatically.\n3. **Bounds Checking**: Implement bounds checking to ensure that operations on strings do not exceed their allocated memory.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstring> // Required for strlen\n#include <string>  // Required for std::string\n\nvoid safePrint(const char* toPrint) {\n    if (toPrint == nullptr) {\n        std::cerr << \"Error: Null pointer received.\" << std::endl;\n        return;\n    }\n\n    // Use std::string to ensure null-termination\n    std::string safeString(toPrint);\n    std::cout << \"String length: \" << safeString.length() << std::endl;\n    std::cout << \"String content: \" << safeString << std::endl;\n}\n\nint main() {\n    const char* myString = \"Hello, World!\";\n    safePrint(myString);\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output stream operations.\n- `<cstring>`: For C-style string operations, including `strlen`.\n- `<string>`: For using `std::string`, which provides safer string handling.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-170: Improper Null Termination](https://cwe.mitre.org/data/definitions/170.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-39e4c0c0-ab5b-476a-903a-9241e1041c23",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises from its inability to handle non-null-terminated strings. If `strlen` is called on a string that is not properly null-terminated, it can lead to undefined behavior, including reading beyond the buffer's bounds, which can cause crashes or expose sensitive data. This is a common issue in C/C++ programming due to the manual management of string termination.\n\n### General Mitigation Advice\n\n1. **Ensure Proper Null-Termination**: Always ensure that strings are null-terminated before passing them to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or classes, such as `std::string` in C++, which manage null-termination automatically.\n3. **Bounds Checking**: Implement bounds checking to ensure that operations on strings do not exceed their allocated memory.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstring> // Required for strlen\n#include <string>  // Required for std::string\n\nvoid safePrint(const char* toPrint) {\n    if (toPrint == nullptr) {\n        std::cerr << \"Error: Null pointer received.\" << std::endl;\n        return;\n    }\n\n    // Use std::string to ensure null-termination\n    std::string safeString(toPrint);\n    std::cout << \"String length: \" << safeString.length() << std::endl;\n    std::cout << \"String content: \" << safeString << std::endl;\n}\n\nint main() {\n    const char* myString = \"Hello, World!\";\n    safePrint(myString);\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output stream operations.\n- `<cstring>`: For C-style string operations, including `strlen`.\n- `<string>`: For using `std::string`, which provides safer string handling.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-170: Improper Null Termination](https://cwe.mitre.org/data/definitions/170.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-7d4dd129-1e50-45a2-9bbd-183aa96a8c83",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises from its inability to handle non-null-terminated strings. If `strlen` is called on a string that is not properly null-terminated, it can lead to undefined behavior, including reading beyond the buffer's bounds, which can cause crashes or expose sensitive data. This is a common issue in C/C++ programming due to the manual management of string termination.\n\n### General Mitigation Advice\n\n1. **Ensure Proper Null-Termination**: Always ensure that strings are null-terminated before passing them to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or classes, such as `std::string` in C++, which manage null-termination automatically.\n3. **Bounds Checking**: Implement bounds checking to ensure that operations on strings do not exceed their allocated memory.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstring> // Required for strlen\n#include <string>  // Required for std::string\n\nvoid safePrint(const char* toPrint) {\n    if (toPrint == nullptr) {\n        std::cerr << \"Error: Null pointer received.\" << std::endl;\n        return;\n    }\n\n    // Use std::string to ensure null-termination\n    std::string safeString(toPrint);\n    std::cout << \"String length: \" << safeString.length() << std::endl;\n    std::cout << \"String content: \" << safeString << std::endl;\n}\n\nint main() {\n    const char* myString = \"Hello, World!\";\n    safePrint(myString);\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output stream operations.\n- `<cstring>`: For C-style string operations, including `strlen`.\n- `<string>`: For using `std::string`, which provides safer string handling.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-170: Improper Null Termination](https://cwe.mitre.org/data/definitions/170.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-c159fdcf-7d51-47f5-b15b-3b1fdffc0a95",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises from its inability to handle non-null-terminated strings. If `strlen` is called on a string that is not properly null-terminated, it can lead to undefined behavior, including reading beyond the buffer's bounds, which can cause crashes or expose sensitive data. This is a common issue in C/C++ programming due to the manual management of string termination.\n\n### General Mitigation Advice\n\n1. **Ensure Proper Null-Termination**: Always ensure that strings are null-terminated before passing them to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or classes, such as `std::string` in C++, which manage null-termination automatically.\n3. **Bounds Checking**: Implement bounds checking to ensure that operations on strings do not exceed their allocated memory.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstring> // Required for strlen\n#include <string>  // Required for std::string\n\nvoid safePrint(const char* toPrint) {\n    if (toPrint == nullptr) {\n        std::cerr << \"Error: Null pointer received.\" << std::endl;\n        return;\n    }\n\n    // Use std::string to ensure null-termination\n    std::string safeString(toPrint);\n    std::cout << \"String length: \" << safeString.length() << std::endl;\n    std::cout << \"String content: \" << safeString << std::endl;\n}\n\nint main() {\n    const char* myString = \"Hello, World!\";\n    safePrint(myString);\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output stream operations.\n- `<cstring>`: For C-style string operations, including `strlen`.\n- `<string>`: For using `std::string`, which provides safer string handling.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-170: Improper Null Termination](https://cwe.mitre.org/data/definitions/170.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-71deb92a-4393-4008-ba3a-ca404140f91d",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability \"Detected Use of Prohibited C Function (strncpy)\" arises when the `strncpy` function is used improperly in C++ programming. The `strncpy` function is often used to copy a specified number of characters from one string to another. However, it can lead to vulnerabilities such as buffer overflows or data truncation if not used carefully. This is because `strncpy` does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can result in undefined behavior when the destination string is used.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using safer string handling functions like `strlcpy` or `snprintf` which ensure null-termination.\n2. **Manual Null-Termination**: If `strncpy` must be used, ensure that the destination buffer is manually null-terminated.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null-terminator.\n4. **Static Analysis Tools**: Use static analysis tools to detect and fix potential buffer overflow issues.\n\n### Source Code Fix Recommendation\n\nGiven the specific vulnerability sink:\n\n```cpp\nstrncpy(dst, \" (Yellow Carp)\", remaining_len);\n```\n\nA safer alternative using `snprintf` would be:\n\n```cpp\n#include <cstdio> // Required for snprintf\n\nsnprintf(dst, remaining_len, \"%s\", \" (Yellow Carp)\");\n```\n\nThis ensures that the destination buffer is null-terminated and prevents buffer overflow by limiting the number of characters written to `remaining_len - 1`.\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstdio>`: This library is required for the `snprintf` function.\n\n### Relevant Resources\n\n- [OWASP C++ Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration - CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nThese resources provide further guidance on secure coding practices and detailed information on related vulnerabilities."
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-5948d1bf-c4bd-4c2c-89be-ac0947bca891",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of `strncpy` in C++ can lead to vulnerabilities if not handled correctly. `strncpy` is often used to copy strings with a specified maximum length, but it does not guarantee null-termination of the destination string if the source string is longer than the specified length. This can lead to buffer overflows, data corruption, and security vulnerabilities.\n\nIn the given code snippet:\n\n```cpp\nstrncpy(thisGPU->base.pdev, pdev_val, PDEV_LEN);\n```\n\nIf `pdev_val` is not null-terminated or is longer than `PDEV_LEN`, `thisGPU->base.pdev` may not be null-terminated, leading to potential vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or `snprintf` which ensure null-termination.\n2. **Manual Null-Termination**: Always manually null-terminate the destination buffer after using `strncpy`.\n3. **Buffer Size Validation**: Ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n4. **Static Analysis Tools**: Use static analysis tools to detect unsafe string operations.\n\n### Source Code Fix Recommendation\n\nReplace `strncpy` with a safer alternative or ensure null-termination:\n\n```cpp\n// Ensure null-termination after strncpy\nstrncpy(thisGPU->base.pdev, pdev_val, PDEV_LEN - 1);\nthisGPU->base.pdev[PDEV_LEN - 1] = '\\0';\n```\n\nOr use `strlcpy` if available:\n\n```cpp\n// Use strlcpy for safer string copy\nstrlcpy(thisGPU->base.pdev, pdev_val, PDEV_LEN);\n```\n\n### Library Dependencies\n\nThe code example does not require any additional library dependencies beyond the standard C++ libraries. However, if using `strlcpy`, ensure that it is available on your platform or consider implementing a custom version.\n\n### OWASP Resources\n\n- [OWASP C++ Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-c1cdcd38-ad21-4db6-b55d-182b8aa3bd3b",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Use of Prohibited C Function (strncpy)\" vulnerability arises when the `strncpy` function is used improperly, potentially leading to buffer overflows or data truncation. In C++, `strncpy` is often used to copy strings with a specified maximum length, but it does not guarantee null-termination if the source string is longer than the specified length. This can lead to undefined behavior when the destination buffer is used as a string.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using safer string handling functions like `strlcpy` or C++ standard library functions such as `std::string` and its member functions.\n2. **Ensure Null-Termination**: Always ensure that the destination buffer is null-terminated after using `strncpy`.\n3. **Buffer Size Management**: Ensure that the destination buffer is large enough to hold the source string and the null terminator.\n4. **Static Analysis Tools**: Use static analysis tools to detect and prevent such vulnerabilities in the codebase.\n\n### Source Code Fix Recommendation\n\nGiven the specific vulnerability sink:\n\n```cpp\nstrncpy(dst, \" (Van Gogh)\", remaining_len);\n```\n\nA safer approach using `strlcpy` (if available) or manual null-termination would be:\n\n```cpp\n#include <cstring> // Required for strlcpy or strncpy\n\n// Assuming strlcpy is available\nstrlcpy(dst, \" (Van Gogh)\", remaining_len);\n\n// If strlcpy is not available, ensure null-termination manually\nstrncpy(dst, \" (Van Gogh)\", remaining_len - 1);\ndst[remaining_len - 1] = '\\0'; // Ensure null-termination\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This header is required for using `strncpy` and `strlcpy` (if available).\n\n### Relevant Resources\n\n- [OWASP C++ Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration: CWE-120](https://cwe.mitre.org/data/definitions/120.html)\n\nThese links were verified to be active and accessible for anonymous users."
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-49de3cf3-e36f-4f35-a32f-5c92c8ff69fe",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, leading to potential memory allocation issues. In the provided code snippet, the `malloc` function is used to allocate memory for a multi-dimensional array. However, the calculation of the size to be allocated is incorrect, which can lead to buffer overflows, memory corruption, or undefined behavior.\n\n### Vulnerability Sink\n\n```cpp\nmalloc(sizeof(unsigned[devices_count][per_device_data_saved][buffer_size]))\n```\n\nThe issue here is that `sizeof` is being used incorrectly. The expression inside `sizeof` is not evaluated as expected, leading to incorrect memory allocation. This can cause the program to access memory out of bounds, resulting in potential security vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Correct Memory Allocation**: Ensure that the size calculation for `malloc` is correct. Use the correct data type size and multiply by the number of elements required.\n2. **Use Safer Alternatives**: Consider using `new` in C++ for memory allocation, which provides type safety and can throw exceptions on failure.\n3. **Check Return Values**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n4. **Initialize Memory**: Use functions like `calloc` that initialize memory to zero, reducing the risk of using uninitialized memory.\n5. **Bounds Checking**: Implement bounds checking to prevent buffer overflows.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib> // Required for malloc and free\n\nunsigned*** allocateMemory(size_t devices_count, size_t per_device_data_saved, size_t buffer_size) {\n    unsigned*** data = (unsigned***)malloc(devices_count * sizeof(unsigned**));\n    if (data == nullptr) {\n        // Handle allocation failure\n        return nullptr;\n    }\n\n    for (size_t i = 0; i < devices_count; ++i) {\n        data[i] = (unsigned**)malloc(per_device_data_saved * sizeof(unsigned*));\n        if (data[i] == nullptr) {\n            // Handle allocation failure\n            // Free previously allocated memory\n            for (size_t j = 0; j < i; ++j) {\n                free(data[j]);\n            }\n            free(data);\n            return nullptr;\n        }\n\n        for (size_t j = 0; j < per_device_data_saved; ++j) {\n            data[i][j] = (unsigned*)malloc(buffer_size * sizeof(unsigned));\n            if (data[i][j] == nullptr) {\n                // Handle allocation failure\n                // Free previously allocated memory\n                for (size_t k = 0; k < j; ++k) {\n                    free(data[i][k]);\n                }\n                free(data[i]);\n                for (size_t k = 0; k < i; ++k) {\n                    free(data[k]);\n                }\n                free(data);\n                return nullptr;\n            }\n        }\n    }\n\n    return data;\n}\n```\n\n### Library Dependencies\n\n- `<cstdlib>`: Required for `malloc` and `free`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-a0aba5c8-89bb-4c23-9e98-3c35be45a7d4",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability \"Detected Use of Prohibited C Function (strncpy)\" arises when the `strncpy` function is used improperly in C++ programming. The `strncpy` function is often used to copy a specified number of characters from one string to another. However, it can lead to vulnerabilities such as buffer overflows or data truncation if not used carefully. This is because `strncpy` does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can result in undefined behavior when the destination string is used.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer alternatives like `strlcpy` or `snprintf` which ensure null-termination of the destination string.\n2. **Manual Null-Termination**: If `strncpy` must be used, ensure that the destination buffer is manually null-terminated.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null-terminator.\n4. **Input Validation**: Validate input lengths before performing string operations to prevent buffer overflows.\n\n### Source Code Fix Recommendation\n\nGiven the specific vulnerability sink:\n\n```cpp\nstrncpy(dst, \" (Raven)\", remaining_len);\n```\n\nA safer approach would be:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n// Ensure dst is large enough to hold the source string plus null-terminator\nif (remaining_len > 0) {\n    strncpy(dst, \" (Raven)\", remaining_len - 1);\n    dst[remaining_len - 1] = '\\0'; // Manually null-terminate\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for using the `strncpy` function.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-88a3cf6c-8132-45ec-8d29-1efa4d91685a",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability \"Detected Use of Prohibited C Function (strncpy)\" in C++ arises from the use of the `strncpy` function, which can lead to buffer overflows or data truncation if not used carefully. The function does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can result in undefined behavior, including potential security vulnerabilities such as buffer overflows.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using safer string handling functions like `strlcpy` or `snprintf` that ensure null-termination.\n2. **Proper Buffer Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n3. **Input Validation**: Validate input lengths before performing string operations to prevent buffer overflows.\n4. **Code Review and Testing**: Regularly review code and perform testing to identify and fix potential vulnerabilities.\n\n### Source Code Fix Recommendation\n\nTo fix the specific vulnerability sink:\n\n```cpp\n#include <cstdio>\n#include <cstring>\n\n// Assuming dst is a properly allocated buffer with size at least remaining_len\nvoid safeCopy(char* dst, size_t remaining_len) {\n    // Use snprintf to ensure null-termination\n    snprintf(dst, remaining_len, \" (Navi10)\");\n}\n```\n\n### Library Dependencies\n\nThe code example requires the following standard C++ libraries:\n\n- `<cstdio>`: For `snprintf`.\n- `<cstring>`: For `strncpy` (if used elsewhere in the code).\n\n### Relevant Resources\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-e4551b88-3b3d-4bc9-ae33-83dd2075e75b",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of the `strncpy` function in C++ can lead to vulnerabilities if not used carefully. `strncpy` is designed to copy a specified number of characters from a source string to a destination buffer. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can lead to buffer overflows, data corruption, and potential security vulnerabilities.\n\nIn the given code snippet:\n\n```cpp\nstrncpy(dst, \" (Vega10)\", remaining_len);\n```\n\nThe function copies the string `\" (Vega10)\"` into the `dst` buffer, but if `remaining_len` is less than the length of `\" (Vega10)\"`, the destination buffer will not be null-terminated, leading to undefined behavior when the string is used.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer alternatives like `strlcpy` or `snprintf` which ensure null-termination of the destination buffer.\n2. **Check Buffer Sizes**: Always ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n3. **Manual Null-Termination**: If using `strncpy`, manually null-terminate the destination buffer.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n\n### Source Code Fix Recommendation\n\nReplace the `strncpy` usage with a safer alternative like `snprintf`:\n\n```cpp\n#include <cstdio> // Required for snprintf\n\nsnprintf(dst, remaining_len, \"%s\", \" (Vega10)\");\n```\n\nThis ensures that the destination buffer is always null-terminated, preventing potential buffer overflow vulnerabilities.\n\n### Library Dependencies\n\nTo execute the code example with `snprintf`, you need to include the following standard library:\n\n- `<cstdio>`: This header is required for using `snprintf`.\n\n### Relevant OWASP Resources\n\n- [OWASP C++ Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-15162d88-fadc-4460-be14-1f96490b0a06",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability \"Detected Use of Prohibited C Function (strncpy)\" in C++ arises from the use of the `strncpy` function, which is known for its potential to cause buffer overflows and other memory-related issues. The function does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can lead to undefined behavior, including memory corruption and security vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using safer string handling functions like `strlcpy` or `snprintf` that ensure null-termination.\n2. **Proper Buffer Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n3. **Input Validation**: Validate input lengths and ensure they do not exceed buffer sizes.\n4. **Static Analysis Tools**: Use static analysis tools to detect and fix potential buffer overflows.\n\n### Source Code Fix Recommendation\n\nReplace the use of `strncpy` with `snprintf` to ensure null-termination and prevent buffer overflow:\n\n```cpp\n#include <cstdio>\n#include <cstring>\n\nvoid safeCopy(char* dst, size_t dst_size) {\n    const char* src = \" (Carrizo / Stoney)\";\n    snprintf(dst, dst_size, \"%s\", src);\n}\n\n// Example usage\nint main() {\n    char buffer[50];\n    safeCopy(buffer, sizeof(buffer));\n    printf(\"%s\\n\", buffer);\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following standard libraries are required:\n\n- `<cstdio>`: For `snprintf` and `printf` functions.\n- `<cstring>`: For string manipulation functions.\n\n### Relevant Resources\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-242: Use of Inherently Dangerous Function](https://cwe.mitre.org/data/definitions/242.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-8756fabb-8b5c-4300-aa18-a8b429a19655",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Use of Prohibited C Function (strncpy)\" vulnerability arises when the `strncpy` function is used improperly, potentially leading to buffer overflows or data truncation. In C++, `strncpy` is often used to copy strings with a specified maximum length, but it does not guarantee null-termination if the source string is longer than the specified length. This can result in undefined behavior if the destination buffer is used as a C-style string.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using safer string handling functions like `strlcpy` (if available) or C++ standard library features such as `std::string` which handle memory management and null-termination automatically.\n2. **Ensure Null-Termination**: Always ensure that the destination buffer is null-terminated after using `strncpy`.\n3. **Buffer Size Management**: Ensure that the destination buffer is large enough to hold the source string and the null-terminator.\n\n### Source Code Fix Recommendation\n\nTo fix the specific vulnerability sink:\n\n```cpp\n#include <cstring> // Required for strncpy\n#include <string>  // Required for std::string\n\nvoid safeCopy(char* dst, size_t dst_size) {\n    std::string source = \" (Iceland / Tonga)\";\n    if (dst_size > 0) {\n        // Use std::string::copy which ensures null-termination\n        size_t copy_len = std::min(source.size(), dst_size - 1);\n        std::copy(source.begin(), source.begin() + copy_len, dst);\n        dst[copy_len] = '\\0'; // Ensure null-termination\n    }\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for `strncpy` and other C-style string functions.\n- `<string>`: Required for `std::string` and its operations.\n\n### Relevant Resources\n\n- [OWASP C++ Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration: CWE-120](https://cwe.mitre.org/data/definitions/120.html)\n\nThese resources provide further guidance on secure coding practices and detailed information on common vulnerabilities and exposures."
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-65e17194-783c-423d-8f07-4d9da697f0ca",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of the `strncpy` function in C++ can lead to vulnerabilities if not used carefully. `strncpy` is designed to copy a specified number of characters from one string to another, but it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can lead to buffer overflows, data corruption, and undefined behavior, which are common security vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer alternatives like `strlcpy` or `snprintf` which ensure null-termination of the destination string.\n2. **Manual Null-Termination**: If `strncpy` must be used, ensure that the destination string is manually null-terminated.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n\n### Source Code Fix Recommendation\n\nHere is a fixed version of the code using `strncpy` with manual null-termination:\n\n```cpp\n#include <cstring> // Required for strncpy\n\nvoid safeCopy(char* dst, size_t dst_size) {\n    const char* src = \" (Kaveri / Kabini / Mullins)\";\n    size_t remaining_len = dst_size - 1; // Reserve space for null terminator\n\n    // Use strncpy and manually null-terminate\n    strncpy(dst, src, remaining_len);\n    dst[remaining_len] = '\\0'; // Ensure null-termination\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for the `strncpy` function.\n\n### Relevant Resources\n\n- [OWASP C++ Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration: CWE-120](https://cwe.mitre.org/data/definitions/120.html)\n\nThese links are verified to be active and accessible for anonymous users."
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-28015c30-5e11-48b5-baaf-497f8c473aaf",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detection of Prohibited C Function (strncpy)\" vulnerability arises when the `strncpy` function is used improperly, potentially leading to buffer overflows or data truncation. The `strncpy` function is designed to copy a specified number of characters from a source string to a destination buffer. However, if the destination buffer is not large enough to hold the copied data, it can result in undefined behavior, including buffer overflows. Additionally, `strncpy` does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters, which can lead to further vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer alternatives like `strlcpy` or `snprintf`, which are designed to handle string copying more safely by ensuring null-termination and preventing buffer overflows.\n2. **Proper Buffer Sizing**: Always ensure that the destination buffer is large enough to hold the source string plus the null-terminator.\n3. **Manual Null-Termination**: If using `strncpy`, manually null-terminate the destination buffer to prevent undefined behavior.\n4. **Static Analysis Tools**: Use static analysis tools to detect and mitigate potential vulnerabilities in the code.\n\n### Source Code Fix Recommendation\n\nGiven the specific vulnerability sink:\n\n```cpp\nstrncpy(dst, \" (Bonaire / Hawaii)\", remaining_len);\n```\n\nA safer approach using `strlcpy` (if available) would be:\n\n```cpp\n#include <string.h> // Required for strlcpy\n\n// Ensure dst is properly sized and null-terminated\nstrlcpy(dst, \" (Bonaire / Hawaii)\", remaining_len);\n```\n\nIf `strlcpy` is not available, you can use `snprintf`:\n\n```cpp\n#include <cstdio> // Required for snprintf\n\n// Ensure dst is properly sized and null-terminated\nsnprintf(dst, remaining_len, \"%s\", \" (Bonaire / Hawaii)\");\n```\n\n### Library Dependencies\n\n- `<string.h>`: Required for `strlcpy` (if available).\n- `<cstdio>`: Required for `snprintf`.\n\n### Relevant Resources\n\n- [OWASP C++ Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration: CWE-120](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-f9067e99-6933-422a-91c0-1d1d88de0e06",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of `strncpy` in C++ can lead to vulnerabilities if not handled correctly. `strncpy` is often used to copy strings with a specified maximum length to prevent buffer overflows. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified length. This can lead to undefined behavior when the destination string is used, potentially causing security vulnerabilities such as buffer overflows or data leaks.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or `snprintf` which ensure null-termination.\n2. **Manual Null-Termination**: If `strncpy` must be used, ensure that the destination buffer is manually null-terminated.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n4. **Static Analysis Tools**: Use static analysis tools to detect unsafe string operations in your code.\n\n### Source Code Fix Recommendation\n\nGiven the specific vulnerability sink:\n\n```cpp\nstrncpy(dst, \" (Hainan / Oland / Verde / Pitcairn / Tahiti)\", remaining_len);\n```\n\nA safer approach would be:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n// Ensure dst is large enough to hold the string and a null terminator\nif (remaining_len > 0) {\n    strncpy(dst, \" (Hainan / Oland / Verde / Pitcairn / Tahiti)\", remaining_len - 1);\n    dst[remaining_len - 1] = '\\0'; // Manually null-terminate\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for the `strncpy` function.\n\n### Relevant Resources\n\n- [OWASP C++ Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration: CWE-120](https://cwe.mitre.org/data/definitions/120.html)\n\nThese links are verified to be active and accessible to anonymous users."
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-4a05bba1-1b63-4e74-a4e3-481ec427412a",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises when it is used on a string that is not null-terminated. This can lead to buffer overflows, as `strlen` will continue reading memory until it encounters a null character, potentially accessing memory beyond the intended buffer. This is a common issue when dealing with user input or data that may not be properly sanitized or validated.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate and sanitize input data to ensure it is null-terminated before using `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions like `strnlen` or C++ string classes (`std::string`) that manage null-termination automatically.\n3. **Buffer Size Checks**: Ensure that buffers are adequately sized and that operations do not exceed their bounds.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n\n### Source Code Fix Recommendation\n\nTo mitigate the vulnerability in the specific sink `strlen(static_info->device_name)`, ensure that `device_name` is null-terminated and consider using safer alternatives:\n\n```cpp\n#include <cstring> // for strnlen\n#include <iostream> // for std::cout\n\n// Assuming static_info is a struct with a char array device_name\nstruct StaticInfo {\n    char device_name[256]; // Ensure this buffer is large enough\n};\n\nsize_t safe_strlen(const char* str, size_t max_len) {\n    return strnlen(str, max_len);\n}\n\nint main() {\n    StaticInfo* static_info = new StaticInfo();\n    // Ensure device_name is null-terminated\n    static_info->device_name[255] = '\\0'; // Ensure null-termination\n\n    // Use safe_strlen instead of strlen\n    size_t length = safe_strlen(static_info->device_name, sizeof(static_info->device_name));\n    std::cout << \"Device name length: \" << length << std::endl;\n\n    delete static_info;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following standard libraries are required:\n\n- `<cstring>`: For `strnlen` function.\n- `<iostream>`: For input/output operations.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-dcb5f2a5-9cc5-4604-8df6-4158c45586cd",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability \"Detected Use of Prohibited C Function (strncpy)\" in C++ arises from the use of the `strncpy` function, which can lead to buffer overflows or non-null-terminated strings if not used carefully. The function copies a specified number of characters from one string to another, but it does not guarantee null-termination if the source string is longer than the specified number of characters. This can result in undefined behavior, including potential security vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or `snprintf`, which ensure null-termination.\n2. **Manual Null-Termination**: If `strncpy` must be used, ensure that the destination buffer is manually null-terminated.\n3. **Buffer Size Management**: Always ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n4. **Input Validation**: Validate input lengths before copying to prevent buffer overflows.\n\n### Source Code Fix Recommendation\n\nReplace the use of `strncpy` with `strlcpy` or `snprintf` to ensure null-termination and prevent buffer overflows. Here's a fixed version of the code:\n\n```cpp\n#include <cstring> // Required for strlcpy\n\n// Assuming strlcpy is available, otherwise implement a custom version\nsize_t strlcpy(char *dst, const char *src, size_t size) {\n    size_t src_len = std::strlen(src);\n    if (size > 0) {\n        size_t copy_len = (src_len >= size) ? size - 1 : src_len;\n        std::memcpy(dst, src, copy_len);\n        dst[copy_len] = '\\0';\n    }\n    return src_len;\n}\n\n// Usage\nstrlcpy(static_info->device_name, gpu_info->drmVersion->desc, MAX_DEVICE_NAME);\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library dependencies are required:\n\n- `<cstring>`: For string manipulation functions like `strlcpy` and `std::memcpy`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-e326de9c-67b6-4cd8-897b-1d0541fa1ddf",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability identified with the use of the `strlen` function in C++ arises when it is used on a potentially uninitialized or null pointer. In the specific case of `strlen(gpu_info->drmVersion->desc)`, if `gpu_info`, `drmVersion`, or `desc` is null, it can lead to undefined behavior, including segmentation faults or crashes. This is a common issue when dealing with pointers in C++ and can lead to security vulnerabilities if not properly handled.\n\n### General Mitigation Advice\n\n1. **Null Check**: Always check pointers for null before dereferencing them.\n2. **Initialization**: Ensure that all pointers are properly initialized before use.\n3. **Error Handling**: Implement robust error handling to manage unexpected null pointers.\n4. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that provide bounds checking.\n\n### Source Code Fix Recommendation\n\nTo mitigate the vulnerability, add null checks before calling `strlen`:\n\n```cpp\n#include <cstring> // Required for strlen\n\n// Assuming gpu_info and its members are properly defined and initialized elsewhere\nif (gpu_info && gpu_info->drmVersion && gpu_info->drmVersion->desc) {\n    size_t length = strlen(gpu_info->drmVersion->desc);\n    // Proceed with using 'length'\n} else {\n    // Handle the error appropriately\n    // For example, log an error or set a default value\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library dependencies are required:\n\n- `<cstring>`: This header is required for the `strlen` function.\n\n### Relevant Resources\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration\n\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-0275735d-197b-4303-a584-c70465e751eb",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of `strncpy` in C++ can lead to vulnerabilities if not handled correctly. The function `strncpy` is designed to copy a specified number of characters from one string to another. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can lead to buffer overflows, data corruption, and potential security vulnerabilities.\n\nIn the provided code snippet:\n\n```cpp\nstrncpy(static_info->device_name, name, MAX_DEVICE_NAME - 1);\n```\n\nThe function copies `MAX_DEVICE_NAME - 1` characters from `name` to `static_info->device_name`, but it does not ensure that `device_name` is null-terminated. This can result in undefined behavior if `name` is longer than `MAX_DEVICE_NAME - 1`.\n\n### General Mitigation Advice\n\n1. **Ensure Null-Termination**: Always ensure that the destination buffer is null-terminated after using `strncpy`.\n2. **Use Safer Alternatives**: Consider using safer alternatives like `strlcpy` (if available) or `std::string` in C++ which handle null-termination automatically.\n3. **Buffer Size Checks**: Always check that the source string length does not exceed the destination buffer size.\n\n### Source Code Fix Recommendation\n\nTo fix the specific vulnerability, ensure that the destination buffer is null-terminated:\n\n```cpp\nstrncpy(static_info->device_name, name, MAX_DEVICE_NAME - 1);\nstatic_info->device_name[MAX_DEVICE_NAME - 1] = '\\0';\n```\n\nAlternatively, use a safer function:\n\n```cpp\n#include <cstring> // Required for strlcpy\n\nstrlcpy(static_info->device_name, name, MAX_DEVICE_NAME);\n```\n\nOr, if using C++:\n\n```cpp\n#include <string> // Required for std::string\n\nstd::string device_name(name);\ndevice_name.copy(static_info->device_name, MAX_DEVICE_NAME - 1);\nstatic_info->device_name[device_name.size()] = '\\0';\n```\n\n### Library Dependencies\n\nFor the code examples provided, the following libraries are required:\n\n- `<cstring>`: Required for `strncpy` and `strlcpy` (if available).\n- `<string>`: Required for `std::string` usage in C++.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nThese links were verified to be active and accessible for anonymous users."
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-23655f44-57c1-462d-b1d1-cef582051591",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe `strlen` function in C and C++ is used to determine the length of a null-terminated string. However, if the input to `strlen` is not properly validated, it can lead to vulnerabilities such as buffer overflows or segmentation faults. This is because `strlen` does not check the bounds of the input string, and if the string is not null-terminated, `strlen` will continue reading memory until it encounters a null byte, potentially accessing memory out of bounds.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate input strings to ensure they are null-terminated before passing them to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions like `strnlen` which allows specifying a maximum length to prevent reading out of bounds.\n3. **Memory Management**: Ensure that all strings are properly allocated and null-terminated.\n4. **Static Analysis**: Use static analysis tools to detect potential vulnerabilities in your code.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstring>\n\n// Original vulnerable code\n// size_t length = strlen(name);\n\n// Fixed code using strnlen\nsize_t safe_strlen(const char* name, size_t max_len) {\n    return strnlen(name, max_len);\n}\n\nint main() {\n    const char* name = \"example\";\n    size_t max_len = 100; // Define a reasonable maximum length\n    size_t length = safe_strlen(name, max_len);\n    std::cout << \"Length of the string is: \" << length << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code, the following standard libraries are required:\n\n- `<iostream>`: For input and output stream operations.\n- `<cstring>`: For C-style string handling functions.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-113a744f-127c-4015-8121-58ac853cb3bc",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability \"Detected Use of Prohibited C Function (strncpy)\" arises when the `strncpy` function is used improperly, potentially leading to buffer overflows or data truncation. In C++, `strncpy` is often used to copy strings, but it does not guarantee null-termination if the source string is longer than the specified number of characters. This can result in undefined behavior if the destination buffer is used as a C-style string. Additionally, if the destination buffer is not large enough to hold the source string, it can lead to buffer overflows, which are a common security vulnerability.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using safer string handling functions like `strlcpy` or C++ standard library functions such as `std::string` which manage memory automatically and provide bounds checking.\n2. **Ensure Null-Termination**: Always ensure that the destination buffer is null-terminated after using `strncpy`.\n3. **Validate Buffer Sizes**: Ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n4. **Input Validation**: Validate and sanitize all input data to ensure it meets expected formats and lengths before processing.\n\n### Source Code Fix Recommendation\n\nReplace the use of `strncpy` with a safer alternative. If using C++11 or later, consider using `std::string` for automatic memory management and bounds checking.\n\n```cpp\n#include <string>\n#include <cstring> // For std::strncpy\n\nvoid safeCopy(char* buffer, size_t bufferSize, const std::string& source) {\n    if (source.size() < bufferSize) {\n        std::strncpy(buffer, source.c_str(), bufferSize - 1);\n        buffer[bufferSize - 1] = '\\0'; // Ensure null-termination\n    } else {\n        // Handle error: source string is too large for the buffer\n    }\n}\n\n// Usage\nvoid exampleUsage(user_info_t* user_info, size_t bufferSize) {\n    char* buffer = new char[bufferSize];\n    std::string source = user_info->pw_name;\n    safeCopy(buffer, bufferSize, source);\n    // Use buffer...\n    delete[] buffer;\n}\n```\n\n### Library Dependencies\n\n- `<string>`: For using `std::string`.\n- `<cstring>`: For using `std::strncpy`.\n\n### Relevant Resources\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-2220d38b-28b1-4890-9bce-da7c15889f06",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question arises from the misuse of the `memcpy` function in C++. The function call `memcpy(&argc, procargs, sizeof(argc))` is problematic because it attempts to copy data into the memory location of `argc`, which is typically used to store the number of command-line arguments. This can lead to undefined behavior, memory corruption, or even security vulnerabilities such as buffer overflows if `procargs` does not contain the expected data or if its size exceeds that of `argc`.\n\n### General Mitigation Advice\n\n1. **Validate Input:** Ensure that the source buffer (`procargs`) contains valid and expected data before performing memory operations.\n2. **Use Safer Functions:** Consider using safer alternatives like `std::copy` or `std::memmove` if overlapping memory areas are involved.\n3. **Bounds Checking:** Always perform bounds checking to ensure that the destination buffer is large enough to hold the data being copied.\n4. **Avoid Direct Memory Manipulation:** Use higher-level abstractions and data structures that manage memory automatically.\n\n### Source Code Fix Recommendation\n\nTo fix the specific vulnerability, ensure that the destination buffer is appropriate and that the size of the data being copied is correct. Here is a revised version of the code:\n\n```cpp\n#include <cstring> // Required for memcpy\n#include <iostream>\n\nint main(int argc, char* argv[]) {\n    // Assuming procargs is a valid source buffer\n    char procargs[] = \"example data\";\n    int new_argc;\n\n    // Correctly copy data into a properly sized buffer\n    if (sizeof(procargs) <= sizeof(new_argc)) {\n        memcpy(&new_argc, procargs, sizeof(new_argc));\n    } else {\n        std::cerr << \"Error: Source data is too large to copy into destination buffer.\" << std::endl;\n    }\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for the `memcpy` function.\n- `<iostream>`: Used for input and output operations.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-24a8d8c6-da95-41d7-b874-9e636f7affc2",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, leading to potential memory allocation issues such as buffer overflows, memory leaks, or improper handling of null pointers. This vulnerability can be exploited to cause a program to crash or behave unpredictably, and in some cases, it can be leveraged to execute arbitrary code.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate input sizes before passing them to `malloc` to ensure they are within expected bounds.\n2. **Check Return Values**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Use Safer Alternatives**: Consider using safer alternatives like `new` in C++ which automatically throws an exception on failure.\n4. **Free Allocated Memory**: Ensure that all allocated memory is properly freed to prevent memory leaks.\n5. **Use Smart Pointers**: In C++, prefer using smart pointers (`std::unique_ptr`, `std::shared_ptr`) which automatically manage memory.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to properly use `malloc` in C++ with necessary checks and memory management:\n\n```cpp\n#include <iostream>\n#include <cstdlib> // Required for malloc and free\n\nint main() {\n    size_t args_size = 100; // Example size\n    void* ptr = malloc(args_size);\n\n    if (ptr == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return 1;\n    }\n\n    // Use the allocated memory\n    // ...\n\n    // Free the allocated memory\n    free(ptr);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<cstdlib>`: For `malloc` and `free` functions.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-401: Improper Release of Memory Before Removing Last Reference ('Memory Leak')](https://cwe.mitre.org/data/definitions/401.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-e711e29b-7fe3-4399-a047-0f6fbab3ff45",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Identified Issue with C Function (malloc)\" vulnerability in C++ typically arises from improper use of the `malloc` function, which can lead to buffer overflows, memory leaks, or other memory-related issues. In the provided code snippet, `malloc(namelen * sizeof(**buffer))`, the vulnerability may occur if `namelen` is not properly validated, leading to an incorrect allocation size. This can result in undefined behavior, including potential security vulnerabilities such as buffer overflows.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate input values to ensure they are within expected ranges before using them in memory allocation functions.\n2. **Use Safer Alternatives**: Consider using safer alternatives like `new` in C++ or `std::vector` for dynamic memory management.\n3. **Check for Allocation Failure**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n4. **Initialize Allocated Memory**: Use functions like `calloc` or explicitly initialize memory to prevent the use of uninitialized memory.\n5. **Free Allocated Memory**: Ensure that all dynamically allocated memory is properly freed to prevent memory leaks.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>  // For malloc and free\n#include <cstring>  // For memset\n\nvoid allocateBuffer(char*** buffer, size_t namelen) {\n    if (namelen == 0 || namelen > SIZE_MAX / sizeof(**buffer)) {\n        // Handle error: invalid size\n        return;\n    }\n\n    *buffer = static_cast<char**>(malloc(namelen * sizeof(**buffer)));\n    if (*buffer == nullptr) {\n        // Handle error: allocation failed\n        return;\n    }\n\n    // Optionally initialize memory\n    memset(*buffer, 0, namelen * sizeof(**buffer));\n}\n\n// Don't forget to free the allocated memory when done\nvoid freeBuffer(char*** buffer) {\n    if (buffer && *buffer) {\n        free(*buffer);\n        *buffer = nullptr;\n    }\n}\n```\n\n### Library Dependencies\n\n- `<cstdlib>`: Required for `malloc` and `free`.\n- `<cstring>`: Required for `memset`.\n\n### Relevant OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n\nThese links have been verified to be active and accessible for anonymous users."
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-f8ba357d-8d34-4bc4-86c0-0885af250869",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the use of the `strlen` function in C++ arises when it is used on user-controlled input without proper validation. The function `strlen(user_info->pw_name)` can lead to a buffer overflow or other security issues if `pw_name` is not properly null-terminated or if it points to an invalid memory location. This can result in undefined behavior, including potential crashes or exploitation by attackers to execute arbitrary code.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that all user inputs are validated and sanitized before being processed.\n2. **Use Safer Alternatives**: Consider using safer string handling functions that limit the number of characters processed, such as `strnlen`.\n3. **Memory Management**: Ensure that all strings are properly null-terminated and that memory is correctly allocated and freed.\n4. **Bounds Checking**: Always perform bounds checking when dealing with strings and buffers.\n\n### Source Code Fix Recommendation\n\nReplace the use of `strlen` with `strnlen` to limit the number of characters processed and prevent buffer overflows. Here is a code example:\n\n```cpp\n#include <cstring>\n#include <pwd.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <iostream>\n\n#define MAX_NAME_LENGTH 256\n\nint main() {\n    struct passwd *user_info;\n    uid_t uid = getuid();\n    user_info = getpwuid(uid);\n\n    if (user_info != nullptr) {\n        // Use strnlen to limit the length of the string processed\n        size_t name_length = strnlen(user_info->pw_name, MAX_NAME_LENGTH);\n        if (name_length < MAX_NAME_LENGTH) {\n            std::cout << \"User name length: \" << name_length << std::endl;\n        } else {\n            std::cerr << \"User name is too long or not properly null-terminated.\" << std::endl;\n        }\n    } else {\n        std::cerr << \"Failed to retrieve user information.\" << std::endl;\n    }\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following libraries are required:\n\n- `<cstring>`: For string handling functions.\n- `<pwd.h>`: For accessing the password database.\n- `<unistd.h>`: For accessing POSIX operating system API.\n- `<sys/types.h>`: For data types used in system calls.\n- `<iostream>`: For input and output stream operations.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-8a36d06f-1590-48a0-8020-9d365a72da37",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ typically arises from improper handling of memory allocation using the `malloc` function. This can lead to various issues such as buffer overflows, memory leaks, or undefined behavior if the allocated memory is not properly managed. Specifically, when using `malloc(size_buffer)`, if `size_buffer` is not correctly calculated or validated, it can result in insufficient memory allocation or excessive allocation, leading to potential security vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Validate Input:** Ensure that the size passed to `malloc` is properly validated and does not exceed expected limits.\n2. **Check Return Value:** Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Use Safer Alternatives:** Consider using safer alternatives like `new` in C++ or higher-level data structures that manage memory automatically.\n4. **Free Allocated Memory:** Ensure that all allocated memory is properly freed to prevent memory leaks.\n5. **Use Static Analysis Tools:** Employ static analysis tools to detect potential memory management issues in the code.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstdlib> // Required for malloc and free\n\nint main() {\n    size_t size_buffer = 1024; // Example buffer size\n    if (size_buffer <= 0 || size_buffer > SIZE_MAX / sizeof(char)) {\n        std::cerr << \"Invalid buffer size\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    char* buffer = (char*)malloc(size_buffer);\n    if (buffer == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    // Use the buffer for some operations\n\n    free(buffer); // Free the allocated memory\n    return EXIT_SUCCESS;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<cstdlib>`: For `malloc` and `free` functions.\n\n### Relevant Links\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-97222dca-1e7f-41d2-8146-c8074933c35b",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability \"Detected Use of Prohibited C Function (strncpy)\" arises when the `strncpy` function is used improperly, potentially leading to buffer overflows or data truncation. In C++, `strncpy` is often used to copy strings, but it does not guarantee null-termination if the source string is longer than the specified number of characters. This can result in undefined behavior if the destination buffer is used as a C-style string. Additionally, if the destination buffer is not large enough to hold the source string, it can lead to buffer overflows, which are a common security vulnerability.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using safer string handling functions like `strlcpy` or C++ standard library functions such as `std::string` which manage memory automatically and provide bounds checking.\n2. **Ensure Null-Termination**: Always ensure that the destination buffer is null-terminated after using `strncpy`.\n3. **Validate Buffer Sizes**: Ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n4. **Input Validation**: Validate and sanitize all input data to ensure it meets expected formats and lengths before processing.\n\n### Source Code Fix Recommendation\n\nReplace the use of `strncpy` with a safer alternative. If using C++11 or later, consider using `std::string` for automatic memory management and bounds checking.\n\n```cpp\n#include <string>\n#include <cstring> // For std::strncpy\n\nvoid safeCopy(char* buffer, size_t bufferSize, const std::string& source) {\n    if (source.size() < bufferSize) {\n        std::strncpy(buffer, source.c_str(), bufferSize - 1);\n        buffer[bufferSize - 1] = '\\0'; // Ensure null-termination\n    } else {\n        // Handle error: source string is too large for the buffer\n    }\n}\n\n// Usage\nvoid exampleUsage(user_info_t* user_info, size_t bufferSize) {\n    char* buffer = new char[bufferSize];\n    std::string source = user_info->pw_name;\n    safeCopy(buffer, bufferSize, source);\n    // Use buffer...\n    delete[] buffer;\n}\n```\n\n### Library Dependencies\n\n- `<string>`: For using `std::string`.\n- `<cstring>`: For using `std::strncpy`.\n\n### Relevant Resources\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-3b86d226-b7e4-4f61-b4e2-45d7ddb22ed5",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Identified Issue with C Function (malloc)\" vulnerability in C++ typically arises from improper use of the `malloc` function, which can lead to buffer overflows, memory leaks, or other memory-related issues. In the provided code snippet, `malloc(namelen * sizeof(**buffer))`, the vulnerability may occur if `namelen` is not properly validated, leading to an incorrect allocation size. This can result in undefined behavior, including potential security vulnerabilities such as buffer overflows.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate input values to ensure they are within expected ranges before using them in memory allocation functions.\n2. **Use Safer Alternatives**: Consider using safer alternatives like `new` in C++ or `std::vector` for dynamic memory management.\n3. **Check for Allocation Failure**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n4. **Initialize Allocated Memory**: Use functions like `calloc` or explicitly initialize memory to prevent the use of uninitialized memory.\n5. **Free Allocated Memory**: Ensure that all dynamically allocated memory is properly freed to prevent memory leaks.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>  // For malloc and free\n#include <cstring>  // For memset\n\nvoid allocateBuffer(char*** buffer, size_t namelen) {\n    if (namelen == 0 || namelen > SIZE_MAX / sizeof(**buffer)) {\n        // Handle error: invalid size\n        return;\n    }\n\n    *buffer = static_cast<char**>(malloc(namelen * sizeof(**buffer)));\n    if (*buffer == nullptr) {\n        // Handle error: allocation failed\n        return;\n    }\n\n    // Optionally initialize memory\n    memset(*buffer, 0, namelen * sizeof(**buffer));\n}\n\n// Don't forget to free the allocated memory when done\nvoid freeBuffer(char*** buffer) {\n    if (buffer && *buffer) {\n        free(*buffer);\n        *buffer = nullptr;\n    }\n}\n```\n\n### Library Dependencies\n\n- `<cstdlib>`: Required for `malloc` and `free`.\n- `<cstring>`: Required for `memset`.\n\n### Relevant OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n\nThese links have been verified to be active and accessible for anonymous users."
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-2988c718-c634-415a-a525-7635fec1729f",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the use of the `strlen` function in C++ arises when it is used on user-controlled input without proper validation. The function `strlen(user_info->pw_name)` can lead to a buffer overflow or other security issues if `pw_name` is not properly null-terminated or if it points to an invalid memory location. This can result in undefined behavior, including potential crashes or exploitation by attackers to execute arbitrary code.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that all user inputs are validated and sanitized before being processed.\n2. **Use Safer Alternatives**: Consider using safer string handling functions that limit the number of characters processed, such as `strnlen`.\n3. **Memory Management**: Ensure that all strings are properly null-terminated and that memory is correctly allocated and freed.\n4. **Bounds Checking**: Always perform bounds checking when dealing with strings and buffers.\n\n### Source Code Fix Recommendation\n\nReplace the use of `strlen` with `strnlen` to limit the number of characters processed and prevent buffer overflows. Here is a code example:\n\n```cpp\n#include <cstring>\n#include <pwd.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <iostream>\n\n#define MAX_NAME_LENGTH 256\n\nint main() {\n    struct passwd *user_info;\n    uid_t uid = getuid();\n    user_info = getpwuid(uid);\n\n    if (user_info != nullptr) {\n        // Use strnlen to limit the length of the string processed\n        size_t name_length = strnlen(user_info->pw_name, MAX_NAME_LENGTH);\n        if (name_length < MAX_NAME_LENGTH) {\n            std::cout << \"User name length: \" << name_length << std::endl;\n        } else {\n            std::cerr << \"User name is too long or not properly null-terminated.\" << std::endl;\n        }\n    } else {\n        std::cerr << \"Failed to retrieve user information.\" << std::endl;\n    }\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following libraries are required:\n\n- `<cstring>`: For string handling functions.\n- `<pwd.h>`: For accessing the password database.\n- `<unistd.h>`: For accessing POSIX operating system API.\n- `<sys/types.h>`: For data types used in system calls.\n- `<iostream>`: For input and output stream operations.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-0a212daf-5943-4576-aff0-0116867e9430",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Use of Prohibited C Function (strncpy)\" vulnerability arises when the `strncpy` function is used improperly in C++ programming. `strncpy` is often used to copy strings with a specified maximum length to prevent buffer overflows. However, it can lead to vulnerabilities if not used carefully, as it does not guarantee null-termination of the destination string if the source string is longer than the specified length. This can result in undefined behavior, including buffer overflows, data corruption, or security vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using safer string handling functions like `strlcpy` or `snprintf` that ensure null-termination.\n2. **Manual Null-Termination**: Always manually null-terminate the destination buffer after using `strncpy`.\n3. **Bounds Checking**: Ensure that the size of the destination buffer is sufficient to hold the source string plus the null terminator.\n4. **Static Analysis Tools**: Use static analysis tools to detect and fix unsafe string operations in the codebase.\n\n### Source Code Fix Recommendation\n\nReplace the use of `strncpy` with a safer alternative or ensure proper null-termination:\n\n```cpp\n#include <cstring> // Required for strlcpy\n\n// Assuming strlcpy is available, otherwise implement a custom version\nsize_t strlcpy(char *dst, const char *src, size_t size) {\n    size_t src_len = std::strlen(src);\n    if (size > 0) {\n        size_t copy_len = (src_len >= size) ? size - 1 : src_len;\n        std::memcpy(dst, src, copy_len);\n        dst[copy_len] = '\\0';\n    }\n    return src_len;\n}\n\n// Fix for the specific vulnerability sink\nstrlcpy(static_info->device_name, name, sizeof(static_info->device_name));\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library dependencies are required:\n\n- `<cstring>`: For string manipulation functions like `strlcpy` and `std::memcpy`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-1ab35a6b-7d57-440b-bdbd-4e062b5dd780",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, leading to potential memory management issues such as memory leaks, buffer overflows, or undefined behavior. This vulnerability typically occurs when the allocated memory is not properly checked, initialized, or freed, which can result in security vulnerabilities or program crashes.\n\n### General Mitigation Advice\n\n1. **Check for NULL**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n2. **Initialize Memory**: Initialize the allocated memory to prevent undefined behavior.\n3. **Free Memory**: Ensure that all allocated memory is properly freed when no longer needed to prevent memory leaks.\n4. **Use Safer Alternatives**: Consider using safer alternatives like `new` in C++ or smart pointers which automatically manage memory.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to properly use `malloc` in C++:\n\n```cpp\n#include <iostream>\n#include <cstdlib> // Required for malloc and free\n\nint main() {\n    size_t sz = 10;\n    int* ptr = (int*)malloc(sz * sizeof(int));\n\n    // Check if malloc succeeded\n    if (ptr == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return 1;\n    }\n\n    // Initialize memory\n    for (size_t i = 0; i < sz; ++i) {\n        ptr[i] = 0;\n    }\n\n    // Use the allocated memory\n    for (size_t i = 0; i < sz; ++i) {\n        std::cout << ptr[i] << \" \";\n    }\n    std::cout << std::endl;\n\n    // Free the allocated memory\n    free(ptr);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<cstdlib>`: For `malloc` and `free` functions.\n\n### Relevant Links\n\n- [CWE-401: Improper Release of Memory Before Removing Last Reference ('Memory Leak')](https://cwe.mitre.org/data/definitions/401.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)\n\nThese links are verified to be active and accessible for anonymous users."
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-5741fb3e-aa30-4758-b9a1-2bc6eb5ddd3b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen(s)` function in C++ is used to find the length of a string. The vulnerability arises when the string `s` is not null-terminated. This can lead to buffer overflows, memory corruption, and other unexpected behavior, as `strlen(s)` will continue reading memory until it encounters a null character.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. This can be done by initializing your strings with a null character at the end, or by manually adding a null character at the end of your string after it has been modified.\n\n## Source Code Fix Recommendation\n\nInstead of using `strlen(s)`, consider using `strnlen(s, MAX_LEN)`, where `MAX_LEN` is the maximum expected length of your string. This function will only read up to `MAX_LEN` characters, preventing potential buffer overflows.\n\n```cpp\n#include <string.h>\n\n#define MAX_LEN 100\n\nchar s[MAX_LEN];\n// ... modify s ...\nsize_t len = strnlen(s, MAX_LEN);\n```\n\n## Library Dependencies\n\nThe `strlen` and `strnlen` functions are part of the `<string.h>` library in C++.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-72e4ccde-05e8-454f-8e45-5f9218de123b",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of the `strncat` function in C++ can lead to vulnerabilities if not used carefully. The function is designed to concatenate a specified number of characters from a source string to a destination string. However, if the destination buffer is not large enough to accommodate the concatenated result, it can lead to buffer overflow vulnerabilities. This can result in undefined behavior, including data corruption, crashes, or security vulnerabilities such as arbitrary code execution.\n\nIn the specific code snippet:\n\n```cpp\nstrncat(result, (const char *)(p + 6), available_space);\n```\n\nThe vulnerability arises if `available_space` does not accurately reflect the remaining space in the `result` buffer, potentially leading to a buffer overflow.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer alternatives like `strncat_s` or C++ string handling functions such as `std::string` which manage memory automatically.\n2. **Proper Buffer Management**: Ensure that the destination buffer is large enough to hold the concatenated result, including the null terminator.\n3. **Boundary Checks**: Always perform boundary checks to ensure that the number of characters to be concatenated does not exceed the available space in the destination buffer.\n\n### Source Code Fix Recommendation\n\nReplace the vulnerable `strncat` usage with a safer alternative. Here is an example using `std::string`:\n\n```cpp\n#include <string>\n#include <cstring>\n\nvoid safeConcatenate(char* result, const char* p, size_t result_size) {\n    std::string temp(result);\n    temp.append(p + 6, std::min(strlen(p + 6), result_size - temp.size() - 1));\n    std::strncpy(result, temp.c_str(), result_size);\n    result[result_size - 1] = '\\0'; // Ensure null termination\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following standard libraries are required:\n\n- `<string>`\n- `<cstring>`\n\n### Relevant Resources\n\n- [OWASP C++ Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration: CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS108330"
                ]
              }
            },
            {
              "id": "glog-c95d18ac-204a-4b01-b1e2-4875795b48dc",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises when it is used improperly, leading to potential buffer overflows or reading beyond the allocated memory. This can occur if the string is not null-terminated or if the pointer passed to `strlen` is invalid. Such issues can lead to undefined behavior, crashes, or security vulnerabilities like information disclosure or code execution.\n\n### General Mitigation Advice\n\n1. **Ensure Null-Termination**: Always ensure that strings are properly null-terminated before passing them to `strlen`.\n2. **Validate Pointers**: Ensure that the pointer passed to `strlen` is valid and points to a properly allocated memory region.\n3. **Use Safer Alternatives**: Consider using safer alternatives like `std::string` in C++ which manage memory automatically and provide length information without needing `strlen`.\n4. **Bounds Checking**: Implement bounds checking to ensure that operations on strings do not exceed their allocated size.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstring> // Required for strlen\n#include <string>  // Required for std::string\n\nint main() {\n    // Using std::string to avoid issues with strlen\n    std::string result = \"Hello, World!\";\n    \n    // Safe way to get the length of the string\n    size_t length = result.length();\n    \n    std::cout << \"Length of the string is: \" << length << std::endl;\n    \n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following standard libraries are required:\n\n- `<iostream>`: For input and output stream operations.\n- `<cstring>`: For C-style string operations (though not used in the fixed example, it's included for context).\n- `<string>`: For using `std::string` which provides safer string handling.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-1b921f17-31e4-441c-872b-8b381b71db5f",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question arises from the use of the `memcpy` function in C/C++ programming, specifically in the line `memcpy(p + i, command, len + 1)`. This line of code can lead to a buffer overflow if the destination buffer `p` does not have enough space to accommodate the data being copied from `command`. Buffer overflows can result in undefined behavior, including data corruption, crashes, and security vulnerabilities such as arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the data being copied. This can be done by performing explicit bounds checking before calling `memcpy`.\n\n2. **Use Safer Alternatives**: Consider using safer alternatives like `memmove` or `strncpy` if applicable, which provide additional safety checks.\n\n3. **Static Analysis Tools**: Utilize static analysis tools to detect potential buffer overflows in your code.\n\n4. **Code Reviews**: Regularly conduct code reviews to identify and fix vulnerabilities.\n\n### Source Code Fix Recommendation\n\nTo fix the specific vulnerability, ensure that the destination buffer `p` has enough space to accommodate the data being copied. Here is a revised version of the code with added bounds checking:\n\n```cpp\n#include <cstring> // Required for memcpy\n\nvoid safe_memcpy(char* p, size_t p_size, const char* command, size_t len, size_t i) {\n    // Ensure there is enough space in the destination buffer\n    if (i + len + 1 <= p_size) {\n        memcpy(p + i, command, len + 1);\n    } else {\n        // Handle error: insufficient space in destination buffer\n        // This could be logging an error, throwing an exception, etc.\n    }\n}\n```\n\n### Library Dependencies\n\nThe code example requires the following library to execute properly:\n\n- `<cstring>`: This library is required for the `memcpy` function.\n\n### Relevant Resources\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-7d98af15-d92a-4327-9db6-13cab2fdcf27",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises from its inability to handle non-null-terminated strings safely. If `strlen` is used on a string that is not properly null-terminated, it can lead to undefined behavior, including buffer overflows, which can be exploited by attackers to execute arbitrary code or cause a denial of service.\n\n### General Mitigation Advice\n\n1. **Ensure Proper Null-Termination**: Always ensure that strings are null-terminated before passing them to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that automatically manage string lengths and null-termination, such as `std::string` in C++.\n3. **Input Validation**: Validate all input data to ensure it conforms to expected formats and lengths.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential vulnerabilities in your code.\n\n### Source Code Fix Recommendation\n\nIf you have a piece of code that uses `strlen` on a potentially unsafe string, you can refactor it to use `std::string` for safer handling:\n\n```cpp\n#include <iostream>\n#include <string>\n\nint main() {\n    std::string command = \"example command\";\n    size_t length = command.length(); // Safe alternative to strlen\n    std::cout << \"Length of command: \" << length << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following standard library dependencies are required:\n\n- `<iostream>`: For input and output stream operations.\n- `<string>`: For using the `std::string` class.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-170: Improper Null Termination](https://cwe.mitre.org/data/definitions/170.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-1c726f04-939c-4885-89b7-586cfc5ca5f0",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Use of Prohibited C Function (strcpy)\" vulnerability arises from the use of the `strcpy` function in C++ programming. This function does not perform bounds checking on the destination buffer, which can lead to buffer overflow vulnerabilities. Buffer overflows can be exploited by attackers to execute arbitrary code, cause a program crash, or corrupt data.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Replace `strcpy` with safer alternatives like `strncpy`, `strlcpy`, or C++ string handling functions such as `std::string` and its member functions.\n2. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the source string, including the null terminator.\n3. **Input Validation**: Validate and sanitize all input data to ensure it does not exceed expected sizes.\n4. **Static Analysis Tools**: Use static analysis tools to detect and fix buffer overflow vulnerabilities in the code.\n\n### Source Code Fix Recommendation\n\nReplace the vulnerable `strcpy` call with a safer alternative. Here is a fixed version of the code using `strncpy`:\n\n```cpp\n#include <cstring> // Required for strncpy\n#include <iostream> // Required for std::cout\n\nstruct Options {\n    const char* config_file_location;\n};\n\nvoid safeCopy(char* folder_path, const Options* options, size_t buffer_size) {\n    // Use strncpy to prevent buffer overflow\n    strncpy(folder_path, options->config_file_location, buffer_size - 1);\n    // Ensure null termination\n    folder_path[buffer_size - 1] = '\\0';\n}\n\nint main() {\n    const size_t buffer_size = 256;\n    char folder_path[buffer_size];\n    Options options = { \"/path/to/config/file\" };\n\n    safeCopy(folder_path, &options, buffer_size);\n\n    std::cout << \"Folder Path: \" << folder_path << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for `strncpy`.\n- `<iostream>`: Required for `std::cout`.\n\n### Relevant Resources\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-fa4699cc-e59d-4acb-ada6-b977ef74203a",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Use of Prohibited C Function (strcpy)\" vulnerability arises from the use of the `strcpy` function in C++ programming. This function does not perform bounds checking on the destination buffer, which can lead to buffer overflow vulnerabilities. Buffer overflows can be exploited by attackers to execute arbitrary code, cause a program crash, or corrupt data.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Replace `strcpy` with safer alternatives like `strncpy`, `strlcpy`, or C++ string handling functions that perform bounds checking.\n2. **Input Validation**: Always validate input data to ensure it does not exceed buffer sizes.\n3. **Buffer Size Management**: Ensure that destination buffers are adequately sized to handle the maximum expected input size plus a null terminator.\n4. **Use Modern C++ Features**: Prefer using C++ standard library features such as `std::string` which handle memory management and bounds checking automatically.\n\n### Source Code Fix Recommendation\n\nReplace the vulnerable `strcpy` usage with a safer alternative. Here is a fixed version of the code using `strncpy`:\n\n```cpp\n#include <cstring> // Required for strncpy\n#include <cstddef> // Required for size_t\n\n// Assuming options->config_file_location is a char array with a known size\nconst size_t buffer_size = sizeof(options->config_file_location);\nstrncpy(options->config_file_location, default_path, buffer_size - 1);\noptions->config_file_location[buffer_size - 1] = '\\0'; // Ensure null termination\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library dependencies are required:\n\n- `<cstring>`: For using `strncpy`.\n- `<cstddef>`: For using `size_t`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-d7d8c7be-8cd0-46c6-891c-a1be8d80ee8f",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises when it is used improperly, leading to potential buffer overflows or reading beyond the intended memory bounds. This can occur if `strlen` is called on a string that is not null-terminated or if the pointer passed to `strlen` is invalid. In the specific case of `strlen(default_path)`, if `default_path` is not properly initialized or null-terminated, it can lead to undefined behavior, potentially causing a program crash or allowing an attacker to execute arbitrary code.\n\n### General Mitigation Advice\n\n1. **Ensure Proper Initialization**: Always initialize strings and ensure they are null-terminated before passing them to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions like `strnlen` or C++ standard library alternatives such as `std::string` which manage memory more safely.\n3. **Input Validation**: Validate all inputs to ensure they are within expected bounds and properly formatted.\n4. **Memory Management**: Use smart pointers or other memory management techniques to avoid dangling pointers and ensure memory is properly allocated and deallocated.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstring> // Required for strlen\n\nint main() {\n    const char* default_path = \"/some/default/path\"; // Ensure this is a valid, null-terminated string\n\n    // Check if default_path is not null\n    if (default_path != nullptr) {\n        size_t length = strlen(default_path);\n        std::cout << \"Length of default_path: \" << length << std::endl;\n    } else {\n        std::cerr << \"Error: default_path is null.\" << std::endl;\n    }\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: Required for input and output operations.\n- `<cstring>`: Required for using `strlen`.\n\n### Relevant Links\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-9d19b7aa-a1d9-4deb-8a3d-0ea1ad73596a",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ typically arises from improper use of the `malloc` function, which can lead to buffer overflows, memory leaks, or undefined behavior. In the specific case of `malloc(strlen(default_path))`, the vulnerability occurs because `malloc` is allocating memory based on the length of the string without accounting for the null terminator. This can lead to buffer overflows when the string is copied into the allocated memory.\n\n### General Mitigation Advice\n\n1. **Allocate Sufficient Memory**: Always allocate enough memory to include the null terminator when dealing with strings.\n2. **Use Safer Functions**: Consider using safer alternatives like `strdup` or C++ constructs like `std::string` which handle memory management automatically.\n3. **Input Validation**: Validate inputs to ensure they are within expected bounds before processing.\n4. **Error Checking**: Always check the return value of `malloc` to ensure memory allocation was successful.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstring>  // For strlen, strcpy\n#include <cstdlib>  // For malloc, free\n\nvoid exampleFunction(const char* default_path) {\n    // Allocate memory including space for the null terminator\n    char* path_copy = (char*)malloc(strlen(default_path) + 1);\n    if (path_copy == nullptr) {\n        // Handle memory allocation failure\n        return;\n    }\n    // Safely copy the string\n    strcpy(path_copy, default_path);\n\n    // Use path_copy...\n\n    // Free the allocated memory\n    free(path_copy);\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for `strlen` and `strcpy`.\n- `<cstdlib>`: Required for `malloc` and `free`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-093f0add-3065-460b-b194-eac7dbe1b623",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Use of Prohibited C Function (strcpy)\" vulnerability arises from the use of the `strcpy` function in C++. This function does not perform bounds checking on the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is larger than the destination buffer. This can result in undefined behavior, including data corruption, crashes, and security vulnerabilities such as arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Replace `strcpy` with safer alternatives like `strncpy`, `strlcpy`, or C++ string handling functions that perform bounds checking.\n2. **Input Validation**: Ensure that input data is validated and sanitized to prevent buffer overflows.\n3. **Buffer Size Management**: Always ensure that destination buffers are large enough to hold the source data, including the null terminator.\n4. **Use Modern C++ Features**: Prefer using C++ standard library features such as `std::string` which handle memory management and bounds checking automatically.\n\n### Source Code Fix Recommendation\n\nReplace the vulnerable `strcpy` usage with a safer alternative. Here is a fixed version of the code using `strncpy`:\n\n```cpp\n#include <cstring> // Required for strncpy\n#include <algorithm> // Required for std::min\n\n// Assuming options->config_file_location is a char array with a known size\nconst size_t buffer_size = sizeof(options->config_file_location);\nstrncpy(options->config_file_location, config_location, buffer_size - 1);\noptions->config_file_location[buffer_size - 1] = '\\0'; // Ensure null termination\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library dependencies are required:\n\n- `<cstring>`: For using `strncpy`.\n- `<algorithm>`: For using `std::min` if needed for additional safety checks.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/): A list of the top ten security risks for web applications.\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/): A quick reference guide for secure coding practices.\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-bb6e4955-7601-4e6a-ae59-6af4e72de5ce",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises when the function is used without proper validation of the input string. If `strlen` is called on a null pointer or an improperly terminated string, it can lead to undefined behavior, including potential crashes or security vulnerabilities such as buffer overflows. This is particularly dangerous when the input is derived from untrusted sources, as it can be exploited to execute arbitrary code or cause denial of service.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate input strings before using them with `strlen`. Ensure that the input is not a null pointer and is properly null-terminated.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that provide bounds checking, such as `strnlen` or C++ standard library classes like `std::string`.\n3. **Error Handling**: Implement robust error handling to manage unexpected or malformed input gracefully.\n\n### Source Code Fix Recommendation\n\nTo mitigate the vulnerability associated with `strlen(config_location)`, ensure that `config_location` is a valid, null-terminated string before calling `strlen`. Here is a code example with a fix:\n\n```cpp\n#include <iostream>\n#include <cstring> // Required for strlen\n#include <stdexcept> // Required for std::runtime_error\n\nvoid processConfigLocation(const char* config_location) {\n    if (config_location == nullptr) {\n        throw std::runtime_error(\"Config location is a null pointer\");\n    }\n\n    // Ensure the string is null-terminated\n    size_t max_length = 1024; // Define a reasonable maximum length\n    size_t length = strnlen(config_location, max_length);\n    if (length == max_length) {\n        throw std::runtime_error(\"Config location string is not properly null-terminated\");\n    }\n\n    // Safe to use strlen now\n    size_t config_length = strlen(config_location);\n    std::cout << \"Config location length: \" << config_length << std::endl;\n}\n\nint main() {\n    const char* config_location = \"/path/to/config\";\n    try {\n        processConfigLocation(config_location);\n    } catch (const std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<cstring>`: For C-style string handling functions like `strlen` and `strnlen`.\n- `<stdexcept>`: For standard exception handling.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/): A list of the most critical web application security risks.\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/): A quick reference guide for secure coding practices.\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-4c242e06-154e-48c6-b0f7-1463ee41e9b0",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ typically arises from improper use of the `malloc` function, which can lead to buffer overflows, memory leaks, or undefined behavior. In the specific case of `malloc(strlen(config_location))`, the vulnerability is due to not allocating enough memory to store the string, as `strlen` returns the length of the string without including the null terminator. This can lead to buffer overflow when the string is copied into the allocated memory.\n\n### General Mitigation Advice\n\n1. **Allocate Sufficient Memory**: Always allocate enough memory to accommodate the data and any additional space required, such as a null terminator for strings.\n2. **Use Safer Functions**: Consider using safer alternatives like `strdup` or C++ constructs like `std::string` which handle memory management automatically.\n3. **Input Validation**: Validate input lengths and ensure they are within expected bounds before performing memory allocations.\n4. **Error Checking**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n\n### Source Code Fix Recommendation\n\nTo fix the specific vulnerability sink, ensure that you allocate enough memory for the string and the null terminator:\n\n```cpp\n#include <cstring>  // For strlen\n#include <cstdlib>  // For malloc, free\n\nvoid exampleFunction(const char* config_location) {\n    // Allocate memory for the string plus the null terminator\n    char* buffer = (char*)malloc(strlen(config_location) + 1);\n    if (buffer == nullptr) {\n        // Handle memory allocation failure\n        return;\n    }\n    strcpy(buffer, config_location);  // Copy the string safely\n    // Use the buffer...\n    free(buffer);  // Free the allocated memory\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following standard libraries are required:\n\n- `<cstring>`: For `strlen` and `strcpy`.\n- `<cstdlib>`: For `malloc` and `free`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-4688b6c6-940f-4951-8ed4-780cdd68ead4",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Use of Prohibited C Function (strcpy)\" vulnerability arises from the use of the `strcpy` function, which does not perform bounds checking and can lead to buffer overflow vulnerabilities. This can result in undefined behavior, including data corruption, crashes, and security vulnerabilities such as arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Replace `strcpy` with safer alternatives like `strncpy`, `strlcpy`, or `std::string` in C++.\n2. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the source data, including the null terminator.\n3. **Input Validation**: Validate all inputs to ensure they do not exceed expected sizes.\n4. **Static Analysis Tools**: Use static analysis tools to detect unsafe function usage in your codebase.\n\n### Source Code Fix Recommendation\n\nReplace the use of `strcpy` with `strncpy` to prevent buffer overflow. Ensure that the destination buffer is properly sized and that the length of the copy operation is limited to the size of the destination buffer minus one for the null terminator.\n\n```cpp\n#include <cstring> // Required for strncpy\n\n// Assuming config_file_path is properly sized\nsize_t buffer_size = /* size of config_file_path */;\nstrncpy(config_file_path + xdg_path_length + 1 + conf_path_length, config_file_location, buffer_size - (xdg_path_length + 1 + conf_path_length) - 1);\nconfig_file_path[buffer_size - 1] = '\\0'; // Ensure null termination\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for using `strncpy`.\n\n### Relevant Resources\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-d124129b-26b5-49be-aba7-16a79401e46d",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of the `strcpy` function in C++ can lead to buffer overflow vulnerabilities if not properly managed. This is because `strcpy` does not perform bounds checking on the destination buffer, which can result in overwriting adjacent memory and potentially leading to arbitrary code execution or program crashes. The specific vulnerability sink in the code snippet:\n\n```cpp\nstrcpy(config_file_path + xdg_path_length + 1, config_conf_path);\n```\n\nis susceptible to buffer overflow if `config_conf_path` is larger than the remaining space in `config_file_path` after `xdg_path_length + 1`.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Replace `strcpy` with safer alternatives like `strncpy`, `strlcpy`, or `std::string` operations that include bounds checking.\n2. **Validate Input**: Ensure that the size of the source string does not exceed the size of the destination buffer.\n3. **Use Modern C++ Features**: Prefer using C++ standard library features such as `std::string` which handle memory management and bounds checking automatically.\n\n### Source Code Fix Recommendation\n\nReplace the `strcpy` call with `strncpy` to ensure that the destination buffer is not overflowed:\n\n```cpp\nstrncpy(config_file_path + xdg_path_length + 1, config_conf_path, sizeof(config_file_path) - xdg_path_length - 1);\n```\n\nEnsure that `config_file_path` is properly null-terminated:\n\n```cpp\nconfig_file_path[sizeof(config_file_path) - 1] = '\\0';\n```\n\n### Library Dependencies\n\nThe code example provided does not require any additional library dependencies beyond the standard C++ library.\n\n### Relevant Resources\n\n- [OWASP C++ Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration: CWE-120](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-54aa5ce7-c83e-4785-a305-8607f6413a0d",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Use of Prohibited C Function (strcpy)\" vulnerability arises when the `strcpy` function is used in C++ programming. This function does not perform bounds checking on the destination buffer, which can lead to buffer overflow vulnerabilities. Buffer overflows can be exploited by attackers to execute arbitrary code, cause a program crash, or corrupt data.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Replace `strcpy` with safer alternatives like `strncpy`, `strlcpy`, or C++ string handling functions such as `std::string` and its member functions.\n2. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the source string, including the null terminator.\n3. **Input Validation**: Validate and sanitize all input data to ensure it does not exceed expected sizes.\n4. **Static Analysis Tools**: Use static analysis tools to detect unsafe function usage and potential buffer overflows.\n\n### Source Code Fix Recommendation\n\nReplace the use of `strcpy` with `strncpy` to prevent buffer overflow. Ensure that the destination buffer is large enough to accommodate the source string and the null terminator.\n\n```cpp\n#include <cstring> // Required for strncpy\n#include <iostream> // Required for std::cout\n\nint main() {\n    const char* xdg_config_dir = \"/path/to/config\";\n    char config_file_path[256]; // Ensure this buffer is large enough\n\n    // Use strncpy instead of strcpy\n    strncpy(config_file_path, xdg_config_dir, sizeof(config_file_path) - 1);\n    config_file_path[sizeof(config_file_path) - 1] = '\\0'; // Null-terminate the string\n\n    std::cout << \"Config file path: \" << config_file_path << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for `strncpy`.\n- `<iostream>`: Required for `std::cout`.\n\n### OWASP Resources\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-3c7efcaa-a661-4a91-bf88-b44efdf4c810",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the use of the `strlen` function in C++ arises when the function is used on a pointer that may not be null-terminated or is not properly validated. This can lead to buffer overflows, undefined behavior, or crashes if the pointer does not point to a valid C-style string. In the specific case of `strlen(xdg_config_dir)`, if `xdg_config_dir` is not properly initialized or validated, it could lead to reading beyond the allocated memory, causing potential security vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that all input data is validated before use. Check that pointers are not null and point to valid, null-terminated strings.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that provide bounds checking, such as `std::string` in C++.\n3. **Memory Management**: Properly manage memory allocation and deallocation to avoid dangling pointers and ensure that strings are null-terminated.\n4. **Static Analysis**: Use static analysis tools to detect potential vulnerabilities in the code.\n\n### Source Code Fix Recommendation\n\nTo mitigate the vulnerability associated with `strlen(xdg_config_dir)`, ensure that `xdg_config_dir` is a valid, null-terminated string before calling `strlen`. Here is an example fix:\n\n```cpp\n#include <iostream>\n#include <cstring> // Required for strlen\n#include <string>  // Required for std::string\n\nint main() {\n    // Example initialization of xdg_config_dir\n    std::string configDir = \"/path/to/config\";\n    const char* xdg_config_dir = configDir.c_str();\n\n    // Ensure xdg_config_dir is not null and is null-terminated\n    if (xdg_config_dir != nullptr && std::strlen(xdg_config_dir) > 0) {\n        std::cout << \"Length of xdg_config_dir: \" << std::strlen(xdg_config_dir) << std::endl;\n    } else {\n        std::cerr << \"Invalid xdg_config_dir\" << std::endl;\n    }\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following libraries are required:\n\n- `<iostream>`: For input and output stream operations.\n- `<cstring>`: For C-style string operations, including `strlen`.\n- `<string>`: For using `std::string` which provides safer string handling.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-f31e7c04-f293-4c0d-abad-6909e67cef96",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, leading to potential memory allocation issues. In the provided code snippet, `malloc(1 * sizeof(struct gpu_process))`, the vulnerability may occur if the size of `struct gpu_process` is not correctly calculated or if the allocation is insufficient for the intended use. This can lead to buffer overflows, memory corruption, or undefined behavior, which are common security vulnerabilities in C/C++ programming.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using `new` in C++ for memory allocation, which provides type safety and automatically calls constructors.\n2. **Check Return Values**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Use sizeof Correctly**: Ensure that `sizeof` is used correctly to calculate the size of the data structure.\n4. **Initialize Memory**: Use functions like `calloc` or `memset` to initialize allocated memory.\n5. **Free Allocated Memory**: Always free allocated memory using `free` to prevent memory leaks.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib> // Required for malloc and free\n#include <cstring> // Required for memset\n\nstruct gpu_process {\n    // Define the structure members\n};\n\nint main() {\n    // Correctly allocate memory for one gpu_process structure\n    struct gpu_process* process = (struct gpu_process*)malloc(sizeof(struct gpu_process));\n    \n    // Check if malloc was successful\n    if (process == nullptr) {\n        // Handle allocation failure\n        return -1;\n    }\n\n    // Initialize memory to zero\n    memset(process, 0, sizeof(struct gpu_process));\n\n    // Use the allocated memory\n\n    // Free the allocated memory\n    free(process);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstdlib>`: Required for `malloc` and `free`.\n- `<cstring>`: Required for `memset`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-e0b85f70-c914-4c60-a756-ef3ce91cd0dd",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ typically arises from improper use of the `malloc` function, which is used to allocate memory dynamically. The specific vulnerability sink `malloc(sizeof(double)` indicates a potential issue where the size of the memory allocated may not be sufficient for the intended use, or the allocation may not be properly checked for success, leading to undefined behavior, memory corruption, or application crashes.\n\n### General Mitigation Advice\n\n1. **Check for Allocation Success**: Always check if `malloc` returns `NULL`, which indicates that the memory allocation failed.\n2. **Use `sizeof` Correctly**: Ensure that the `sizeof` operator is used correctly to allocate the appropriate amount of memory.\n3. **Initialize Allocated Memory**: Consider using `calloc` instead of `malloc` if you need the allocated memory to be initialized to zero.\n4. **Free Allocated Memory**: Always free the allocated memory using `free` to prevent memory leaks.\n5. **Use Safer Alternatives**: In C++, prefer using `new` and `delete` or smart pointers like `std::unique_ptr` and `std::shared_ptr` for memory management.\n\n### Source Code Fix Recommendation\n\nHere is a corrected version of the code snippet using `malloc`:\n\n```cpp\n#include <cstdlib>  // Required for malloc and free\n#include <iostream> // Required for std::cout\n\nint main() {\n    // Correctly allocate memory for one double\n    double* ptr = (double*)malloc(sizeof(double));\n    \n    // Check if allocation was successful\n    if (ptr == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return 1;\n    }\n\n    // Use the allocated memory\n    *ptr = 3.14;\n    std::cout << \"Value: \" << *ptr << std::endl;\n\n    // Free the allocated memory\n    free(ptr);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstdlib>`: Required for `malloc` and `free`.\n- `<iostream>`: Required for input and output operations.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-c82429e0-cd04-4fe5-803f-808d8b3a43c9",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used incorrectly, leading to potential memory allocation issues. In the provided example, `malloc(sizeof(int64))` is used, which can cause problems if `int64` is not properly defined or if the size calculation is incorrect. This can lead to buffer overflows, memory corruption, or undefined behavior.\n\n### General Mitigation Advice\n\n1. **Use `sizeof` Correctly**: Ensure that `sizeof` is used with the correct type or variable.\n2. **Check for NULL**: Always check if `malloc` returns `NULL` to handle memory allocation failures gracefully.\n3. **Use `new` in C++**: Prefer using `new` and `delete` in C++ for memory management, as they are type-safe and provide constructors and destructors.\n4. **Avoid Magic Numbers**: Use defined constants or `sizeof` to avoid hardcoding sizes.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstdlib> // Required for malloc and free\n\nint main() {\n    // Correct usage of malloc with sizeof\n    int64_t* ptr = (int64_t*)malloc(sizeof(int64_t));\n    if (ptr == NULL) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return 1;\n    }\n\n    // Use the allocated memory\n    *ptr = 42;\n    std::cout << \"Value: \" << *ptr << std::endl;\n\n    // Free the allocated memory\n    free(ptr);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<cstdlib>`: For `malloc` and `free` functions.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-30ee7978-73cc-4caa-a40f-1d27ae8b4df4",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used incorrectly, leading to potential memory allocation issues. In the provided example, `malloc(sizeof(int64))` is used, which can cause problems if `int64` is not properly defined or if the size calculation is incorrect. This can lead to buffer overflows, memory corruption, or undefined behavior.\n\n### General Mitigation Advice\n\n1. **Use `sizeof` Correctly**: Ensure that `sizeof` is used with the correct type or variable.\n2. **Check for NULL**: Always check if `malloc` returns `NULL` to handle memory allocation failures gracefully.\n3. **Use `new` in C++**: Prefer using `new` and `delete` in C++ for memory management, as they are type-safe and provide constructors and destructors.\n4. **Avoid Magic Numbers**: Use defined constants or `sizeof` to avoid hardcoding sizes.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstdlib> // Required for malloc and free\n\nint main() {\n    // Correct usage of malloc with sizeof\n    int64_t* ptr = (int64_t*)malloc(sizeof(int64_t));\n    if (ptr == NULL) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return 1;\n    }\n\n    // Use the allocated memory\n    *ptr = 42;\n    std::cout << \"Value: \" << *ptr << std::endl;\n\n    // Free the allocated memory\n    free(ptr);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<cstdlib>`: For `malloc` and `free` functions.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-b592aa2f-2b98-453c-aaa0-362563edcf2c",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used incorrectly, leading to potential memory allocation issues. In the provided example, `malloc(sizeof(int64))` is used, which can cause problems if `int64` is not properly defined or if the size calculation is incorrect. This can lead to buffer overflows, memory corruption, or undefined behavior.\n\n### General Mitigation Advice\n\n1. **Use `sizeof` Correctly**: Ensure that `sizeof` is used with the correct type or variable.\n2. **Check for NULL**: Always check if `malloc` returns `NULL` to handle memory allocation failures gracefully.\n3. **Use `new` in C++**: Prefer using `new` and `delete` in C++ for memory management, as they are type-safe and provide constructors and destructors.\n4. **Avoid Magic Numbers**: Use defined constants or `sizeof` to avoid hardcoding sizes.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstdlib> // Required for malloc and free\n\nint main() {\n    // Correct usage of malloc with sizeof\n    int64_t* ptr = (int64_t*)malloc(sizeof(int64_t));\n    if (ptr == NULL) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return 1;\n    }\n\n    // Use the allocated memory\n    *ptr = 42;\n    std::cout << \"Value: \" << *ptr << std::endl;\n\n    // Free the allocated memory\n    free(ptr);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<cstdlib>`: For `malloc` and `free` functions.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-742d1227-ee59-4510-bd7c-666d0660371b",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used incorrectly, leading to potential memory allocation issues. In the provided example, `malloc(sizeof(int64))` is used, which can cause problems if `int64` is not properly defined or if the size calculation is incorrect. This can lead to buffer overflows, memory corruption, or undefined behavior.\n\n### General Mitigation Advice\n\n1. **Use `sizeof` Correctly**: Ensure that `sizeof` is used with the correct type or variable.\n2. **Check for NULL**: Always check if `malloc` returns `NULL` to handle memory allocation failures gracefully.\n3. **Use `new` in C++**: Prefer using `new` and `delete` in C++ for memory management, as they are type-safe and provide constructors and destructors.\n4. **Avoid Magic Numbers**: Use defined constants or `sizeof` to avoid hardcoding sizes.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstdlib> // Required for malloc and free\n\nint main() {\n    // Correct usage of malloc with sizeof\n    int64_t* ptr = (int64_t*)malloc(sizeof(int64_t));\n    if (ptr == NULL) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return 1;\n    }\n\n    // Use the allocated memory\n    *ptr = 42;\n    std::cout << \"Value: \" << *ptr << std::endl;\n\n    // Free the allocated memory\n    free(ptr);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<cstdlib>`: For `malloc` and `free` functions.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-529402e5-fd3d-4828-b9b3-bad2d59a1750",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ programming arises when the `malloc` function is used improperly, leading to potential memory allocation issues. This can result in buffer overflows, memory leaks, or undefined behavior if the allocated memory is not managed correctly. In the provided code snippet, the vulnerability is related to the allocation of memory for an array of `struct tpu_chip_usage_data` using `malloc`.\n\n### Vulnerability Sink\n\n```cpp\nmalloc(tpu_chip_count * sizeof(struct tpu_chip_usage_data))\n```\n\n### General Mitigation Advice\n\n1. **Check for NULL**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n2. **Use `calloc`**: Consider using `calloc` instead of `malloc` for zero-initialized memory allocation.\n3. **Free Memory**: Ensure that all allocated memory is properly freed to avoid memory leaks.\n4. **Use Smart Pointers**: In C++, prefer using smart pointers (e.g., `std::unique_ptr`, `std::shared_ptr`) to manage dynamic memory automatically.\n5. **Bounds Checking**: Implement bounds checking to prevent buffer overflows.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib> // for malloc and free\n#include <iostream> // for std::cerr\n\nstruct tpu_chip_usage_data {\n    // Define the structure members here\n};\n\nint main() {\n    size_t tpu_chip_count = 10; // Example value, should be set appropriately\n    struct tpu_chip_usage_data* data = static_cast<struct tpu_chip_usage_data*>(\n        malloc(tpu_chip_count * sizeof(struct tpu_chip_usage_data))\n    );\n\n    if (data == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    // Use the allocated memory\n\n    // Free the allocated memory\n    free(data);\n\n    return EXIT_SUCCESS;\n}\n```\n\n### Library Dependencies\n\n- `<cstdlib>`: Required for `malloc` and `free`.\n- `<iostream>`: Required for error output using `std::cerr`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-401: Improper Release of Memory Before Removing Last Reference ('Memory Leak')](https://cwe.mitre.org/data/definitions/401.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-25f53dbe-1a9e-49c2-b1c2-47bf2108b7f1",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ programming arises when dynamic memory allocation is improperly handled, potentially leading to buffer overflows, memory leaks, or undefined behavior. The specific vulnerability sink in the code example is:\n\n```cpp\nmalloc(samples_count * sizeof(*samples))\n```\n\nThis line of code attempts to allocate memory for `samples_count` elements of the type pointed to by `samples`. If `samples_count` is not properly validated, it can lead to an integer overflow or insufficient memory allocation, causing potential security vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate `samples_count` to ensure it is within a reasonable range and non-negative.\n2. **Check for Integer Overflow**: Before performing the multiplication, check if the multiplication would result in an integer overflow.\n3. **Check for NULL**: After calling `malloc`, always check if the returned pointer is `NULL` to ensure that the memory allocation was successful.\n4. **Use Safer Alternatives**: Consider using safer memory allocation functions like `calloc`, which initializes the allocated memory to zero.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>  // Required for malloc and free\n#include <climits>  // Required for SIZE_MAX\n\n// Function to safely allocate memory\nvoid* safe_malloc(size_t count, size_t size) {\n    if (count == 0 || size == 0 || count > SIZE_MAX / size) {\n        // Handle error: invalid size or potential overflow\n        return nullptr;\n    }\n    void* ptr = malloc(count * size);\n    if (ptr == nullptr) {\n        // Handle error: memory allocation failed\n    }\n    return ptr;\n}\n\n// Usage\nsize_t samples_count = /* some validated value */;\nvoid* samples = safe_malloc(samples_count, sizeof(*samples));\nif (samples == nullptr) {\n    // Handle allocation failure\n}\n\n// Remember to free the allocated memory when done\nfree(samples);\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following standard libraries are required:\n\n- `<cstdlib>`: For `malloc` and `free`.\n- `<climits>`: For `SIZE_MAX`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-190: Integer Overflow or Wraparound](https://cwe.mitre.org/data/definitions/190.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-fad0862b-e262-4748-b98d-2792c8f9c025",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of `strncpy` in C++ can lead to vulnerabilities if not handled correctly. `strncpy` is often used to copy strings, but it does not guarantee null-termination if the source string is longer than the specified number of characters. This can lead to buffer overflows, data corruption, and security vulnerabilities, especially if the destination buffer is not properly sized or if the copied string is used without ensuring it is null-terminated.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or `snprintf` which ensure null-termination.\n2. **Proper Buffer Sizing**: Always ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n3. **Manual Null-Termination**: If using `strncpy`, manually null-terminate the destination buffer.\n4. **Static Analysis Tools**: Use static analysis tools to detect unsafe string operations in your code.\n\n### Source Code Fix Recommendation\n\nFor the specific vulnerability sink:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n// Assuming PDEV_LEN is defined and is the size of gpu_infos[*count].base.pdev\nstrncpy(gpu_infos[*count].base.pdev, pciInfo.busIdLegacy, PDEV_LEN - 1);\ngpu_infos[*count].base.pdev[PDEV_LEN - 1] = '\\0'; // Ensure null-termination\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for using `strncpy`.\n\n### Relevant Resources\n\n- [OWASP C++ Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration: CWE-120](https://cwe.mitre.org/data/definitions/120.html)\n\nThese links were verified to be active and accessible to anonymous users."
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-d921e84a-7d3b-44c6-a5dd-7eaead261213",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ typically arises from improper handling of dynamic memory allocation using the `malloc` function. This can lead to various issues such as memory leaks, buffer overflows, or undefined behavior if the allocated memory is not properly managed. In the given code snippet, the vulnerability is associated with the allocation of memory for an array of `struct dcmi_proc_mem_info` using `malloc`.\n\n### General Mitigation Advice\n\n1. **Check for NULL Pointers**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n2. **Use `sizeof` Correctly**: Ensure that the size calculation in `malloc` is correct and matches the intended data structure.\n3. **Free Allocated Memory**: Always free the allocated memory when it is no longer needed to prevent memory leaks.\n4. **Use Safer Alternatives**: Consider using C++ memory management features like `new`/`delete` or smart pointers (`std::unique_ptr`, `std::shared_ptr`) for better safety and exception handling.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <memory>\n\n// Assuming struct definition\nstruct dcmi_proc_mem_info {\n    // struct members\n};\n\nint main() {\n    const size_t MAX_PROC_NUM = 100; // Example size\n    std::unique_ptr<dcmi_proc_mem_info[]> procMemInfo(new (std::nothrow) dcmi_proc_mem_info[MAX_PROC_NUM]);\n\n    if (!procMemInfo) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return 1;\n    }\n\n    // Use procMemInfo...\n\n    // No need to manually free memory, unique_ptr will handle it\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<memory>`: For using smart pointers like `std::unique_ptr`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-401: Improper Release of Memory Before Removing Last Reference ('Memory Leak')](https://cwe.mitre.org/data/definitions/401.html)\n- [CWE-476: NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/476.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-1a5a06e1-7478-4200-b7fa-64cc7ae855dd",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of `strncpy` in C++ can lead to vulnerabilities if not handled correctly. The function is designed to copy a specified number of characters from one string to another. However, it does not guarantee null-termination of the destination string if the source string is longer than the specified number of characters. This can lead to buffer overflows, data corruption, and undefined behavior, which are common security vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or `snprintf` that ensure null-termination.\n2. **Manual Null-Termination**: Always manually null-terminate the destination buffer if using `strncpy`.\n3. **Bounds Checking**: Ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n4. **Static Analysis Tools**: Use static analysis tools to detect unsafe string operations in your code.\n\n### Source Code Fix Recommendation\n\nTo fix the specific vulnerability sink:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n// Assuming MAX_DEVICE_NAME is defined and large enough\nstrncpy(static_info->device_name, (char*) chip_info->chip_name, MAX_DEVICE_NAME - 1);\nstatic_info->device_name[MAX_DEVICE_NAME - 1] = '\\0'; // Ensure null-termination\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for using `strncpy`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-dc4b70c6-b119-49a1-9c71-e2cb79a496df",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe `strlen` function in C and C++ is used to determine the length of a null-terminated string. However, if the input string is not properly null-terminated, `strlen` can read beyond the intended memory bounds, leading to undefined behavior, potential crashes, or security vulnerabilities such as buffer overflows. This issue is often categorized under improper validation of array indices or buffer boundaries.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that all strings passed to `strlen` are properly null-terminated.\n2. **Buffer Size Management**: Always allocate sufficient buffer size to accommodate the string and the null terminator.\n3. **Use Safer Alternatives**: Consider using safer string handling functions that limit the number of characters processed, such as `strnlen` in C99 or later.\n4. **Static Analysis Tools**: Utilize static analysis tools to detect potential buffer overflows and improper memory access.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstring> // Required for strlen\n\nint main() {\n    const char* safeString = \"Hello, World!\";\n    // Ensure the string is null-terminated\n    size_t length = strlen(safeString);\n    std::cout << \"Length of the string is: \" << length << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output stream operations.\n- `<cstring>`: For C-style string handling functions like `strlen`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-0b9bda85-04df-42bd-8d00-e7cf61d19b76",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises when it is used improperly, particularly when calculating the length of a string starting from a specific offset. If the offset is not validated properly, it can lead to reading beyond the bounds of the string, potentially causing undefined behavior, crashes, or security vulnerabilities such as buffer overflows.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate the offset to ensure it is within the bounds of the string.\n2. **Use Safer Alternatives**: Consider using safer string handling functions that automatically manage buffer sizes.\n3. **Bounds Checking**: Implement explicit bounds checking before performing operations that involve offsets.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstring>\n\n// Original vulnerable code\n// size_t length = strlen(line + offset);\n\n// Fixed code\nsize_t safe_strlen(const char* str, size_t offset) {\n    if (str == nullptr) {\n        return 0;\n    }\n    size_t str_length = strlen(str);\n    if (offset >= str_length) {\n        std::cerr << \"Offset is out of bounds.\" << std::endl;\n        return 0;\n    }\n    return strlen(str + offset);\n}\n\nint main() {\n    const char* line = \"Example string\";\n    size_t offset = 8; // Example offset\n    size_t length = safe_strlen(line, offset);\n    std::cout << \"Length of string from offset: \" << length << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following standard libraries are required:\n\n- `<iostream>`: For input and output stream operations.\n- `<cstring>`: For C-style string handling functions.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-00626b4f-248a-4490-99ef-5b60da97006e",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen(s)` function in C++ is used to find the length of a string. The vulnerability arises when the string `s` is not null-terminated. This can lead to buffer overflows, memory corruption, and other unexpected behavior, as `strlen(s)` will continue reading memory until it encounters a null character.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. This can be done by initializing your strings with a null character at the end, or by manually adding a null character at the end of your string after it has been modified.\n\n## Source Code Fix Recommendation\n\nInstead of using `strlen(s)`, consider using `strnlen(s, MAX_LEN)`, where `MAX_LEN` is the maximum expected length of your string. This function will only read up to `MAX_LEN` characters, preventing potential buffer overflows.\n\n```cpp\n#include <string.h>\n\n#define MAX_LEN 100\n\nchar s[MAX_LEN];\n// ... modify s ...\nsize_t len = strnlen(s, MAX_LEN);\n```\n\n## Library Dependencies\n\nThe `strlen` and `strnlen` functions are part of the `<string.h>` library in C++.\n\n## References\n\n- [OWASP C++](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-42cfa7bb-a143-4afc-83a3-d61c0c693f27",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises from its inability to handle null-terminated strings safely. If `strlen` is used on a string that is not properly null-terminated, it can lead to undefined behavior, including buffer overflows, which can be exploited to execute arbitrary code or cause a program crash. This is particularly dangerous when the input to `strlen` is derived from untrusted sources.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate input to ensure it is properly null-terminated before passing it to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that automatically manage string lengths and null-termination.\n3. **Bounds Checking**: Implement bounds checking to ensure that the string length does not exceed the buffer size.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential vulnerabilities in your code.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstring> // Required for strlen\n\nint main() {\n    const char* line = \"example string\"; // Ensure this is null-terminated\n    size_t length = 0;\n\n    // Check if the string is null-terminated\n    if (line != nullptr && std::strchr(line, '\\0') != nullptr) {\n        length = strlen(line);\n        std::cout << \"Length of the string is: \" << length << std::endl;\n    } else {\n        std::cerr << \"Error: String is not properly null-terminated.\" << std::endl;\n    }\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output stream operations.\n- `<cstring>`: For C-style string handling functions like `strlen`.\n\n### Relevant Links\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-39351bba-d8c3-424d-a5ec-2bca2ead551a",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, leading to potential memory allocation issues. Specifically, the vulnerability can occur if the size of the memory allocation is not correctly calculated, which can result in buffer overflows, memory corruption, or undefined behavior. In the provided code snippet, `malloc(sizeof(struct dcmi_chip_info))`, the vulnerability may arise if the `struct dcmi_chip_info` is not properly defined or if the size calculation does not account for all necessary elements, leading to insufficient memory allocation.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using `new` in C++ for memory allocation, which automatically calls constructors and is type-safe.\n2. **Check Return Values**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Proper Size Calculation**: Ensure that the size passed to `malloc` accurately reflects the total memory needed, including all elements and padding.\n4. **Initialize Allocated Memory**: Use functions like `calloc` or manually initialize memory to prevent the use of uninitialized memory.\n5. **Free Allocated Memory**: Always pair `malloc` with `free` to prevent memory leaks.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib> // Required for malloc and free\n#include <cstring> // Required for memset\n\nstruct dcmi_chip_info {\n    // Define the structure members here\n    int someField;\n    // Add other fields as necessary\n};\n\nint main() {\n    // Correctly calculate the size of the structure\n    struct dcmi_chip_info* chipInfo = (struct dcmi_chip_info*)malloc(sizeof(struct dcmi_chip_info));\n    \n    // Check if malloc was successful\n    if (chipInfo == nullptr) {\n        // Handle allocation failure\n        return -1;\n    }\n\n    // Initialize the allocated memory\n    memset(chipInfo, 0, sizeof(struct dcmi_chip_info));\n\n    // Use the allocated memory\n    chipInfo->someField = 42;\n\n    // Free the allocated memory\n    free(chipInfo);\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstdlib>`: Required for `malloc` and `free`.\n- `<cstring>`: Required for `memset`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "glog-e83e50ed-d054-48bc-b219-1d3324cdd8d7",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/extract_gpuinfo_msm.c"
                },
                "region": {
                  "startLine": 481,
                  "startColumn": 6,
                  "endLine": 481,
                  "endColumn": 79,
                  "charOffset": 14991,
                  "charLength": 73,
                  "snippet": {
                    "text": "strncpy(static_info->device_name, name, sizeof(static_info->device_name))",
                    "rendered": {
                      "text": "strncpy(static_info->device_name, name, sizeof(static_info->device_name))",
                      "markdown": "`strncpy(static_info->device_name, name, sizeof(static_info->device_name))`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_msm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14991,
                        "charLength": 73
                      },
                      "insertedContent": {
                        "text": "strcpy_s(static_info->device_name,  sizeof(static_info->device_name,  name)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_msm.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14991,
                        "charLength": 73
                      },
                      "insertedContent": {
                        "text": "strlcpy(static_info->device_name,  name,  sizeof(static_info->device_name)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e7857526-e73f-41b9-a12b-113236898c89",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/plot.c"
                },
                "region": {
                  "startLine": 114,
                  "startColumn": 22,
                  "endLine": 114,
                  "endColumn": 39,
                  "charOffset": 4382,
                  "charLength": 17,
                  "snippet": {
                    "text": "strlen(legend[i])",
                    "rendered": {
                      "text": "strlen(legend[i])",
                      "markdown": "`strlen(legend[i])`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/plot.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4382,
                        "charLength": 17
                      },
                      "insertedContent": {
                        "text": "strlen_s(legend[i], <size of legend[i]>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/plot.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4382,
                        "charLength": 17
                      },
                      "insertedContent": {
                        "text": "strnlen(legend[i], <size of legend[i]>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-97f30f23-a251-4f4c-9edf-e8b01e92989c",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/extract_gpuinfo_panfrost.c"
                },
                "region": {
                  "startLine": 280,
                  "startColumn": 6,
                  "endLine": 280,
                  "endColumn": 79,
                  "charOffset": 9608,
                  "charLength": 73,
                  "snippet": {
                    "text": "strncpy(static_info->device_name, name, sizeof(static_info->device_name))",
                    "rendered": {
                      "text": "strncpy(static_info->device_name, name, sizeof(static_info->device_name))",
                      "markdown": "`strncpy(static_info->device_name, name, sizeof(static_info->device_name))`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_panfrost.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9608,
                        "charLength": 73
                      },
                      "insertedContent": {
                        "text": "strcpy_s(static_info->device_name,  sizeof(static_info->device_name,  name)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_panfrost.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9608,
                        "charLength": 73
                      },
                      "insertedContent": {
                        "text": "strlcpy(static_info->device_name,  name,  sizeof(static_info->device_name)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-8f06b672-563b-4b7e-95a8-adbe198051db",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/interface.c"
                },
                "region": {
                  "startLine": 2011,
                  "startColumn": 38,
                  "endLine": 2011,
                  "endColumn": 57,
                  "charOffset": 80660,
                  "charLength": 19,
                  "snippet": {
                    "text": "strlen(messages[i])",
                    "rendered": {
                      "text": "strlen(messages[i])",
                      "markdown": "`strlen(messages[i])`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 80660,
                        "charLength": 19
                      },
                      "insertedContent": {
                        "text": "strlen_s(messages[i], <size of messages[i]>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 80660,
                        "charLength": 19
                      },
                      "insertedContent": {
                        "text": "strnlen(messages[i], <size of messages[i]>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-01e52bba-084b-4af7-9b2d-fd27924c199a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/interface.c"
                },
                "region": {
                  "startLine": 2015,
                  "startColumn": 24,
                  "endLine": 2015,
                  "endColumn": 43,
                  "charOffset": 80819,
                  "charLength": 19,
                  "snippet": {
                    "text": "strlen(messages[i])",
                    "rendered": {
                      "text": "strlen(messages[i])",
                      "markdown": "`strlen(messages[i])`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 80819,
                        "charLength": 19
                      },
                      "insertedContent": {
                        "text": "strlen_s(messages[i], <size of messages[i]>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 80819,
                        "charLength": 19
                      },
                      "insertedContent": {
                        "text": "strnlen(messages[i], <size of messages[i]>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-5b636645-750a-4db0-a28a-9b00b63a2aaa",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/interface.c"
                },
                "region": {
                  "startLine": 2018,
                  "startColumn": 27,
                  "endLine": 2018,
                  "endColumn": 46,
                  "charOffset": 80952,
                  "charLength": 19,
                  "snippet": {
                    "text": "strlen(messages[i])",
                    "rendered": {
                      "text": "strlen(messages[i])",
                      "markdown": "`strlen(messages[i])`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 80952,
                        "charLength": 19
                      },
                      "insertedContent": {
                        "text": "strlen_s(messages[i], <size of messages[i]>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 80952,
                        "charLength": 19
                      },
                      "insertedContent": {
                        "text": "strnlen(messages[i], <size of messages[i]>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-bc541c0e-709a-41ac-8007-9522e9a4b4d7",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/interface.c"
                },
                "region": {
                  "startLine": 1963,
                  "startColumn": 26,
                  "endLine": 1963,
                  "endColumn": 66,
                  "charOffset": 78795,
                  "charLength": 40,
                  "snippet": {
                    "text": "strlen(gpuinfo->static_info.device_name)",
                    "rendered": {
                      "text": "strlen(gpuinfo->static_info.device_name)",
                      "markdown": "`strlen(gpuinfo->static_info.device_name)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 78795,
                        "charLength": 40
                      },
                      "insertedContent": {
                        "text": "strlen_s(gpuinfo->static_info.device_name, <size of gpuinfo->static_info.device_name>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 78795,
                        "charLength": 40
                      },
                      "insertedContent": {
                        "text": "strnlen(gpuinfo->static_info.device_name, <size of gpuinfo->static_info.device_name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-3d3b261e-b9ce-41a4-96ad-1fb09536485e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/interface.c"
                },
                "region": {
                  "startLine": 1410,
                  "startColumn": 24,
                  "endLine": 1410,
                  "endColumn": 73,
                  "charOffset": 58041,
                  "charLength": 49,
                  "snippet": {
                    "text": "strlen(all_procs.processes[i].process->user_name)",
                    "rendered": {
                      "text": "strlen(all_procs.processes[i].process->user_name)",
                      "markdown": "`strlen(all_procs.processes[i].process->user_name)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 58041,
                        "charLength": 49
                      },
                      "insertedContent": {
                        "text": "strlen_s(all_procs.processes[i].process->user_name, <size of all_procs.processes[i].process->user_name>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 58041,
                        "charLength": 49
                      },
                      "insertedContent": {
                        "text": "strnlen(all_procs.processes[i].process->user_name, <size of all_procs.processes[i].process->user_name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-767d9983-8224-4723-9f2f-c30796e215c9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/interface.c"
                },
                "region": {
                  "startLine": 885,
                  "startColumn": 41,
                  "endLine": 885,
                  "endColumn": 115,
                  "charOffset": 34958,
                  "charLength": 74,
                  "snippet": {
                    "text": "malloc(total_processes_count * sizeof(*merged_devices_processes.processes)",
                    "rendered": {
                      "text": "malloc(total_processes_count * sizeof(*merged_devices_processes.processes)",
                      "markdown": "`malloc(total_processes_count * sizeof(*merged_devices_processes.processes)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 34958,
                        "charLength": 74
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-1b55f86a-7195-4fbd-aee3-1415268a9140",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/interface.c"
                },
                "region": {
                  "startLine": 473,
                  "startColumn": 24,
                  "endLine": 473,
                  "endColumn": 39,
                  "charOffset": 18395,
                  "charLength": 15,
                  "snippet": {
                    "text": "strlen(prelude)",
                    "rendered": {
                      "text": "strlen(prelude)",
                      "markdown": "`strlen(prelude)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18395,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strlen_s(prelude, <size of prelude>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18395,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strnlen(prelude, <size of prelude>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a8eb351d-3c35-4b1b-b4ac-8970a5562d17",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/interface.c"
                },
                "region": {
                  "startLine": 487,
                  "startColumn": 50,
                  "endLine": 487,
                  "endColumn": 77,
                  "charOffset": 18978,
                  "charLength": 27,
                  "snippet": {
                    "text": "strlen(inside_braces_right)",
                    "rendered": {
                      "text": "strlen(inside_braces_right)",
                      "markdown": "`strlen(inside_braces_right)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18978,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "strlen_s(inside_braces_right, <size of inside_braces_right>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18978,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "strnlen(inside_braces_right, <size of inside_braces_right>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-88694392-9b5f-4b0a-bd8e-5c7ba8373f68",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/interface.c"
                },
                "region": {
                  "startLine": 327,
                  "startColumn": 21,
                  "endLine": 327,
                  "endColumn": 76,
                  "charOffset": 12700,
                  "charLength": 55,
                  "snippet": {
                    "text": "malloc(interface->num_plots * sizeof(*interface->plots)",
                    "rendered": {
                      "text": "malloc(interface->num_plots * sizeof(*interface->plots)",
                      "markdown": "`malloc(interface->num_plots * sizeof(*interface->plots)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12700,
                        "charLength": 55
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-5ccfb32c-adff-43dc-a729-e01944c68a9f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/interface.c"
                },
                "region": {
                  "startLine": 316,
                  "startColumn": 57,
                  "endLine": 316,
                  "endColumn": 72,
                  "charOffset": 12331,
                  "charLength": 15,
                  "snippet": {
                    "text": "strlen(toPrint)",
                    "rendered": {
                      "text": "strlen(toPrint)",
                      "markdown": "`strlen(toPrint)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12331,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strlen_s(toPrint, <size of toPrint>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12331,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strnlen(toPrint, <size of toPrint>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-2b40fd04-5776-4f3c-8c36-64bfa8e2a3c1",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/interface.c"
                },
                "region": {
                  "startLine": 306,
                  "startColumn": 61,
                  "endLine": 306,
                  "endColumn": 76,
                  "charOffset": 11918,
                  "charLength": 15,
                  "snippet": {
                    "text": "strlen(toPrint)",
                    "rendered": {
                      "text": "strlen(toPrint)",
                      "markdown": "`strlen(toPrint)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11918,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strlen_s(toPrint, <size of toPrint>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11918,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strnlen(toPrint, <size of toPrint>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a67a8db3-e450-4d14-b349-065eb5ccb849",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/interface.c"
                },
                "region": {
                  "startLine": 313,
                  "startColumn": 65,
                  "endLine": 313,
                  "endColumn": 80,
                  "charOffset": 12213,
                  "charLength": 15,
                  "snippet": {
                    "text": "strlen(toPrint)",
                    "rendered": {
                      "text": "strlen(toPrint)",
                      "markdown": "`strlen(toPrint)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12213,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strlen_s(toPrint, <size of toPrint>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 12213,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strnlen(toPrint, <size of toPrint>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-6a465949-789b-4b54-80d5-580a8ad6dc7b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/interface.c"
                },
                "region": {
                  "startLine": 299,
                  "startColumn": 61,
                  "endLine": 299,
                  "endColumn": 76,
                  "charOffset": 11627,
                  "charLength": 15,
                  "snippet": {
                    "text": "strlen(toPrint)",
                    "rendered": {
                      "text": "strlen(toPrint)",
                      "markdown": "`strlen(toPrint)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11627,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strlen_s(toPrint, <size of toPrint>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11627,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strnlen(toPrint, <size of toPrint>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-39737e0c-9e3d-428a-8bb0-eabf377ca11c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/interface.c"
                },
                "region": {
                  "startLine": 284,
                  "startColumn": 57,
                  "endLine": 284,
                  "endColumn": 72,
                  "charOffset": 11049,
                  "charLength": 15,
                  "snippet": {
                    "text": "strlen(toPrint)",
                    "rendered": {
                      "text": "strlen(toPrint)",
                      "markdown": "`strlen(toPrint)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11049,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strlen_s(toPrint, <size of toPrint>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 11049,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strnlen(toPrint, <size of toPrint>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-39e4c0c0-ab5b-476a-903a-9241e1041c23",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/interface.c"
                },
                "region": {
                  "startLine": 270,
                  "startColumn": 61,
                  "endLine": 270,
                  "endColumn": 76,
                  "charOffset": 10467,
                  "charLength": 15,
                  "snippet": {
                    "text": "strlen(toPrint)",
                    "rendered": {
                      "text": "strlen(toPrint)",
                      "markdown": "`strlen(toPrint)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10467,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strlen_s(toPrint, <size of toPrint>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10467,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strnlen(toPrint, <size of toPrint>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-7d4dd129-1e50-45a2-9bbd-183aa96a8c83",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/interface.c"
                },
                "region": {
                  "startLine": 277,
                  "startColumn": 65,
                  "endLine": 277,
                  "endColumn": 80,
                  "charOffset": 10766,
                  "charLength": 15,
                  "snippet": {
                    "text": "strlen(toPrint)",
                    "rendered": {
                      "text": "strlen(toPrint)",
                      "markdown": "`strlen(toPrint)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10766,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strlen_s(toPrint, <size of toPrint>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10766,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strnlen(toPrint, <size of toPrint>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c159fdcf-7d51-47f5-b15b-3b1fdffc0a95",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/interface.c"
                },
                "region": {
                  "startLine": 263,
                  "startColumn": 61,
                  "endLine": 263,
                  "endColumn": 76,
                  "charOffset": 10176,
                  "charLength": 15,
                  "snippet": {
                    "text": "strlen(toPrint)",
                    "rendered": {
                      "text": "strlen(toPrint)",
                      "markdown": "`strlen(toPrint)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10176,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strlen_s(toPrint, <size of toPrint>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10176,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strnlen(toPrint, <size of toPrint>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-71deb92a-4393-4008-ba3a-ca404140f91d",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/extract_gpuinfo_amdgpu.c"
                },
                "region": {
                  "startLine": 600,
                  "startColumn": 8,
                  "endLine": 600,
                  "endColumn": 53,
                  "charOffset": 20234,
                  "charLength": 45,
                  "snippet": {
                    "text": "strncpy(dst, \" (Yellow Carp)\", remaining_len)",
                    "rendered": {
                      "text": "strncpy(dst, \" (Yellow Carp)\", remaining_len)",
                      "markdown": "`strncpy(dst, \" (Yellow Carp)\", remaining_len)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_amdgpu.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 20234,
                        "charLength": 45
                      },
                      "insertedContent": {
                        "text": "strcpy_s(dst,  remaining_len,  \" (Yellow Carp)\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_amdgpu.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 20234,
                        "charLength": 45
                      },
                      "insertedContent": {
                        "text": "strlcpy(dst,  \" (Yellow Carp)\",  remaining_len)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-5948d1bf-c4bd-4c2c-89be-ac0947bca891",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/extract_gpuinfo_intel.c"
                },
                "region": {
                  "startLine": 120,
                  "startColumn": 2,
                  "endLine": 120,
                  "endColumn": 49,
                  "charOffset": 4668,
                  "charLength": 47,
                  "snippet": {
                    "text": "strncpy(thisGPU->base.pdev, pdev_val, PDEV_LEN)",
                    "rendered": {
                      "text": "strncpy(thisGPU->base.pdev, pdev_val, PDEV_LEN)",
                      "markdown": "`strncpy(thisGPU->base.pdev, pdev_val, PDEV_LEN)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_intel.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4668,
                        "charLength": 47
                      },
                      "insertedContent": {
                        "text": "strcpy_s(thisGPU->base.pdev,  PDEV_LEN,  pdev_val)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_intel.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4668,
                        "charLength": 47
                      },
                      "insertedContent": {
                        "text": "strlcpy(thisGPU->base.pdev,  pdev_val,  PDEV_LEN)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c1cdcd38-ad21-4db6-b55d-182b8aa3bd3b",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/extract_gpuinfo_amdgpu.c"
                },
                "region": {
                  "startLine": 595,
                  "startColumn": 8,
                  "endLine": 595,
                  "endColumn": 50,
                  "charOffset": 20107,
                  "charLength": 42,
                  "snippet": {
                    "text": "strncpy(dst, \" (Van Gogh)\", remaining_len)",
                    "rendered": {
                      "text": "strncpy(dst, \" (Van Gogh)\", remaining_len)",
                      "markdown": "`strncpy(dst, \" (Van Gogh)\", remaining_len)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_amdgpu.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 20107,
                        "charLength": 42
                      },
                      "insertedContent": {
                        "text": "strcpy_s(dst,  remaining_len,  \" (Van Gogh)\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_amdgpu.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 20107,
                        "charLength": 42
                      },
                      "insertedContent": {
                        "text": "strlcpy(dst,  \" (Van Gogh)\",  remaining_len)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-49de3cf3-e36f-4f35-a32f-5c92c8ff69fe",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/interface_ring_buffer.c"
                },
                "region": {
                  "startLine": 14,
                  "startColumn": 32,
                  "endLine": 14,
                  "endColumn": 106,
                  "charOffset": 505,
                  "charLength": 74,
                  "snippet": {
                    "text": "malloc(sizeof(unsigned[devices_count][per_device_data_saved][buffer_size])",
                    "rendered": {
                      "text": "malloc(sizeof(unsigned[devices_count][per_device_data_saved][buffer_size])",
                      "markdown": "`malloc(sizeof(unsigned[devices_count][per_device_data_saved][buffer_size])`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface_ring_buffer.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 505,
                        "charLength": 74
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a0aba5c8-89bb-4c23-9e98-3c35be45a7d4",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/extract_gpuinfo_amdgpu.c"
                },
                "region": {
                  "startLine": 585,
                  "startColumn": 8,
                  "endLine": 585,
                  "endColumn": 47,
                  "charOffset": 19856,
                  "charLength": 39,
                  "snippet": {
                    "text": "strncpy(dst, \" (Raven)\", remaining_len)",
                    "rendered": {
                      "text": "strncpy(dst, \" (Raven)\", remaining_len)",
                      "markdown": "`strncpy(dst, \" (Raven)\", remaining_len)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_amdgpu.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19856,
                        "charLength": 39
                      },
                      "insertedContent": {
                        "text": "strcpy_s(dst,  remaining_len,  \" (Raven)\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_amdgpu.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19856,
                        "charLength": 39
                      },
                      "insertedContent": {
                        "text": "strlcpy(dst,  \" (Raven)\",  remaining_len)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-88a3cf6c-8132-45ec-8d29-1efa4d91685a",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/extract_gpuinfo_amdgpu.c"
                },
                "region": {
                  "startLine": 590,
                  "startColumn": 8,
                  "endLine": 590,
                  "endColumn": 48,
                  "charOffset": 19980,
                  "charLength": 40,
                  "snippet": {
                    "text": "strncpy(dst, \" (Navi10)\", remaining_len)",
                    "rendered": {
                      "text": "strncpy(dst, \" (Navi10)\", remaining_len)",
                      "markdown": "`strncpy(dst, \" (Navi10)\", remaining_len)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_amdgpu.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19980,
                        "charLength": 40
                      },
                      "insertedContent": {
                        "text": "strcpy_s(dst,  remaining_len,  \" (Navi10)\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_amdgpu.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19980,
                        "charLength": 40
                      },
                      "insertedContent": {
                        "text": "strlcpy(dst,  \" (Navi10)\",  remaining_len)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e4551b88-3b3d-4bc9-ae33-83dd2075e75b",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/extract_gpuinfo_amdgpu.c"
                },
                "region": {
                  "startLine": 580,
                  "startColumn": 8,
                  "endLine": 580,
                  "endColumn": 48,
                  "charOffset": 19731,
                  "charLength": 40,
                  "snippet": {
                    "text": "strncpy(dst, \" (Vega10)\", remaining_len)",
                    "rendered": {
                      "text": "strncpy(dst, \" (Vega10)\", remaining_len)",
                      "markdown": "`strncpy(dst, \" (Vega10)\", remaining_len)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_amdgpu.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19731,
                        "charLength": 40
                      },
                      "insertedContent": {
                        "text": "strcpy_s(dst,  remaining_len,  \" (Vega10)\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_amdgpu.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19731,
                        "charLength": 40
                      },
                      "insertedContent": {
                        "text": "strlcpy(dst,  \" (Vega10)\",  remaining_len)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-15162d88-fadc-4460-be14-1f96490b0a06",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/extract_gpuinfo_amdgpu.c"
                },
                "region": {
                  "startLine": 575,
                  "startColumn": 8,
                  "endLine": 575,
                  "endColumn": 58,
                  "charOffset": 19596,
                  "charLength": 50,
                  "snippet": {
                    "text": "strncpy(dst, \" (Carrizo / Stoney)\", remaining_len)",
                    "rendered": {
                      "text": "strncpy(dst, \" (Carrizo / Stoney)\", remaining_len)",
                      "markdown": "`strncpy(dst, \" (Carrizo / Stoney)\", remaining_len)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_amdgpu.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19596,
                        "charLength": 50
                      },
                      "insertedContent": {
                        "text": "strcpy_s(dst,  remaining_len,  \" (Carrizo / Stoney)\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_amdgpu.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19596,
                        "charLength": 50
                      },
                      "insertedContent": {
                        "text": "strlcpy(dst,  \" (Carrizo / Stoney)\",  remaining_len)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-8756fabb-8b5c-4300-aa18-a8b429a19655",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/extract_gpuinfo_amdgpu.c"
                },
                "region": {
                  "startLine": 570,
                  "startColumn": 8,
                  "endLine": 570,
                  "endColumn": 57,
                  "charOffset": 19462,
                  "charLength": 49,
                  "snippet": {
                    "text": "strncpy(dst, \" (Iceland / Tonga)\", remaining_len)",
                    "rendered": {
                      "text": "strncpy(dst, \" (Iceland / Tonga)\", remaining_len)",
                      "markdown": "`strncpy(dst, \" (Iceland / Tonga)\", remaining_len)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_amdgpu.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19462,
                        "charLength": 49
                      },
                      "insertedContent": {
                        "text": "strcpy_s(dst,  remaining_len,  \" (Iceland / Tonga)\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_amdgpu.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19462,
                        "charLength": 49
                      },
                      "insertedContent": {
                        "text": "strlcpy(dst,  \" (Iceland / Tonga)\",  remaining_len)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-65e17194-783c-423d-8f07-4d9da697f0ca",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/extract_gpuinfo_amdgpu.c"
                },
                "region": {
                  "startLine": 565,
                  "startColumn": 8,
                  "endLine": 565,
                  "endColumn": 67,
                  "charOffset": 19318,
                  "charLength": 59,
                  "snippet": {
                    "text": "strncpy(dst, \" (Kaveri / Kabini / Mullins)\", remaining_len)",
                    "rendered": {
                      "text": "strncpy(dst, \" (Kaveri / Kabini / Mullins)\", remaining_len)",
                      "markdown": "`strncpy(dst, \" (Kaveri / Kabini / Mullins)\", remaining_len)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_amdgpu.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19318,
                        "charLength": 59
                      },
                      "insertedContent": {
                        "text": "strcpy_s(dst,  remaining_len,  \" (Kaveri / Kabini / Mullins)\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_amdgpu.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19318,
                        "charLength": 59
                      },
                      "insertedContent": {
                        "text": "strlcpy(dst,  \" (Kaveri / Kabini / Mullins)\",  remaining_len)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-28015c30-5e11-48b5-baaf-497f8c473aaf",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/extract_gpuinfo_amdgpu.c"
                },
                "region": {
                  "startLine": 560,
                  "startColumn": 8,
                  "endLine": 560,
                  "endColumn": 58,
                  "charOffset": 19183,
                  "charLength": 50,
                  "snippet": {
                    "text": "strncpy(dst, \" (Bonaire / Hawaii)\", remaining_len)",
                    "rendered": {
                      "text": "strncpy(dst, \" (Bonaire / Hawaii)\", remaining_len)",
                      "markdown": "`strncpy(dst, \" (Bonaire / Hawaii)\", remaining_len)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_amdgpu.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19183,
                        "charLength": 50
                      },
                      "insertedContent": {
                        "text": "strcpy_s(dst,  remaining_len,  \" (Bonaire / Hawaii)\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_amdgpu.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19183,
                        "charLength": 50
                      },
                      "insertedContent": {
                        "text": "strlcpy(dst,  \" (Bonaire / Hawaii)\",  remaining_len)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f9067e99-6933-422a-91c0-1d1d88de0e06",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/extract_gpuinfo_amdgpu.c"
                },
                "region": {
                  "startLine": 555,
                  "startColumn": 8,
                  "endLine": 555,
                  "endColumn": 84,
                  "charOffset": 19022,
                  "charLength": 76,
                  "snippet": {
                    "text": "strncpy(dst, \" (Hainan / Oland / Verde / Pitcairn / Tahiti)\", remaining_len)",
                    "rendered": {
                      "text": "strncpy(dst, \" (Hainan / Oland / Verde / Pitcairn / Tahiti)\", remaining_len)",
                      "markdown": "`strncpy(dst, \" (Hainan / Oland / Verde / Pitcairn / Tahiti)\", remaining_len)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_amdgpu.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19022,
                        "charLength": 76
                      },
                      "insertedContent": {
                        "text": "strcpy_s(dst,  remaining_len,  \" (Hainan / Oland / Verde / Pitcairn / Tahiti)\")"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_amdgpu.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19022,
                        "charLength": 76
                      },
                      "insertedContent": {
                        "text": "strlcpy(dst,  \" (Hainan / Oland / Verde / Pitcairn / Tahiti)\",  remaining_len)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-4a05bba1-1b63-4e74-a4e3-481ec427412a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/extract_gpuinfo_amdgpu.c"
                },
                "region": {
                  "startLine": 547,
                  "startColumn": 19,
                  "endLine": 547,
                  "endColumn": 51,
                  "charOffset": 18751,
                  "charLength": 32,
                  "snippet": {
                    "text": "strlen(static_info->device_name)",
                    "rendered": {
                      "text": "strlen(static_info->device_name)",
                      "markdown": "`strlen(static_info->device_name)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_amdgpu.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18751,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "strlen_s(static_info->device_name, <size of static_info->device_name>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_amdgpu.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18751,
                        "charLength": 32
                      },
                      "insertedContent": {
                        "text": "strnlen(static_info->device_name, <size of static_info->device_name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-dcb5f2a5-9cc5-4604-8df6-4158c45586cd",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/extract_gpuinfo_amdgpu.c"
                },
                "region": {
                  "startLine": 543,
                  "startColumn": 4,
                  "endLine": 543,
                  "endColumn": 86,
                  "charOffset": 18555,
                  "charLength": 82,
                  "snippet": {
                    "text": "strncpy(static_info->device_name, gpu_info->drmVersion->desc, MAX_DEVICE_NAME - 1)",
                    "rendered": {
                      "text": "strncpy(static_info->device_name, gpu_info->drmVersion->desc, MAX_DEVICE_NAME - 1)",
                      "markdown": "`strncpy(static_info->device_name, gpu_info->drmVersion->desc, MAX_DEVICE_NAME - 1)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_amdgpu.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18555,
                        "charLength": 82
                      },
                      "insertedContent": {
                        "text": "strcpy_s(static_info->device_name,  MAX_DEVICE_NAME - 1,  gpu_info->drmVersion->desc)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_amdgpu.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18555,
                        "charLength": 82
                      },
                      "insertedContent": {
                        "text": "strlcpy(static_info->device_name,  gpu_info->drmVersion->desc,  MAX_DEVICE_NAME - 1)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e326de9c-67b6-4cd8-897b-1d0541fa1ddf",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/extract_gpuinfo_amdgpu.c"
                },
                "region": {
                  "startLine": 542,
                  "startColumn": 43,
                  "endLine": 542,
                  "endColumn": 77,
                  "charOffset": 18513,
                  "charLength": 34,
                  "snippet": {
                    "text": "strlen(gpu_info->drmVersion->desc)",
                    "rendered": {
                      "text": "strlen(gpu_info->drmVersion->desc)",
                      "markdown": "`strlen(gpu_info->drmVersion->desc)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_amdgpu.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18513,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "strlen_s(gpu_info->drmVersion->desc, <size of gpu_info->drmVersion->desc>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_amdgpu.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18513,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "strnlen(gpu_info->drmVersion->desc, <size of gpu_info->drmVersion->desc>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-0275735d-197b-4303-a584-c70465e751eb",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/extract_gpuinfo_amdgpu.c"
                },
                "region": {
                  "startLine": 540,
                  "startColumn": 4,
                  "endLine": 540,
                  "endColumn": 64,
                  "charOffset": 18346,
                  "charLength": 60,
                  "snippet": {
                    "text": "strncpy(static_info->device_name, name, MAX_DEVICE_NAME - 1)",
                    "rendered": {
                      "text": "strncpy(static_info->device_name, name, MAX_DEVICE_NAME - 1)",
                      "markdown": "`strncpy(static_info->device_name, name, MAX_DEVICE_NAME - 1)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_amdgpu.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18346,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strcpy_s(static_info->device_name,  MAX_DEVICE_NAME - 1,  name)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_amdgpu.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18346,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "strlcpy(static_info->device_name,  name,  MAX_DEVICE_NAME - 1)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-23655f44-57c1-462d-b1d1-cef582051591",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/extract_gpuinfo_amdgpu.c"
                },
                "region": {
                  "startLine": 539,
                  "startColumn": 14,
                  "endLine": 539,
                  "endColumn": 26,
                  "charOffset": 18326,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(name)",
                    "rendered": {
                      "text": "strlen(name)",
                      "markdown": "`strlen(name)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_amdgpu.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18326,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(name, <size of name>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_amdgpu.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18326,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(name, <size of name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-113a744f-127c-4015-8121-58ac853cb3bc",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/get_process_info_mac.c"
                },
                "region": {
                  "startLine": 46,
                  "startColumn": 2,
                  "endLine": 46,
                  "endColumn": 47,
                  "charOffset": 1359,
                  "charLength": 45,
                  "snippet": {
                    "text": "strncpy(*buffer, user_info->pw_name, namelen)",
                    "rendered": {
                      "text": "strncpy(*buffer, user_info->pw_name, namelen)",
                      "markdown": "`strncpy(*buffer, user_info->pw_name, namelen)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/get_process_info_mac.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1359,
                        "charLength": 45
                      },
                      "insertedContent": {
                        "text": "strcpy_s(*buffer,  namelen,  user_info->pw_name)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/get_process_info_mac.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1359,
                        "charLength": 45
                      },
                      "insertedContent": {
                        "text": "strlcpy(*buffer,  user_info->pw_name,  namelen)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-2220d38b-28b1-4890-9bce-da7c15889f06",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/get_process_info_mac.c"
                },
                "region": {
                  "startLine": 72,
                  "startColumn": 2,
                  "endLine": 72,
                  "endColumn": 38,
                  "charOffset": 2129,
                  "charLength": 36,
                  "snippet": {
                    "text": "memcpy(&argc, procargs, sizeof(argc)",
                    "rendered": {
                      "text": "memcpy(&argc, procargs, sizeof(argc)",
                      "markdown": "`memcpy(&argc, procargs, sizeof(argc)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/get_process_info_mac.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2129,
                        "charLength": 36
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&argc, <size of &argc>,  procargs,  sizeof(argc)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-24a8d8c6-da95-41d7-b874-9e636f7affc2",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/get_process_info_mac.c"
                },
                "region": {
                  "startLine": 96,
                  "startColumn": 15,
                  "endLine": 96,
                  "endColumn": 32,
                  "charOffset": 2794,
                  "charLength": 17,
                  "snippet": {
                    "text": "malloc(args_size)",
                    "rendered": {
                      "text": "malloc(args_size)",
                      "markdown": "`malloc(args_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/get_process_info_mac.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2794,
                        "charLength": 17
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e711e29b-7fe3-4399-a047-0f6fbab3ff45",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/get_process_info_mac.c"
                },
                "region": {
                  "startLine": 45,
                  "startColumn": 12,
                  "endLine": 45,
                  "endColumn": 45,
                  "charOffset": 1321,
                  "charLength": 33,
                  "snippet": {
                    "text": "malloc(namelen * sizeof(**buffer)",
                    "rendered": {
                      "text": "malloc(namelen * sizeof(**buffer)",
                      "markdown": "`malloc(namelen * sizeof(**buffer)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/get_process_info_mac.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1321,
                        "charLength": 33
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f8ba357d-8d34-4bc4-86c0-0885af250869",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/get_process_info_mac.c"
                },
                "region": {
                  "startLine": 44,
                  "startColumn": 25,
                  "endLine": 44,
                  "endColumn": 51,
                  "charOffset": 1277,
                  "charLength": 26,
                  "snippet": {
                    "text": "strlen(user_info->pw_name)",
                    "rendered": {
                      "text": "strlen(user_info->pw_name)",
                      "markdown": "`strlen(user_info->pw_name)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/get_process_info_mac.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1277,
                        "charLength": 26
                      },
                      "insertedContent": {
                        "text": "strlen_s(user_info->pw_name, <size of user_info->pw_name>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/get_process_info_mac.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1277,
                        "charLength": 26
                      },
                      "insertedContent": {
                        "text": "strnlen(user_info->pw_name, <size of user_info->pw_name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-8a36d06f-1590-48a0-8020-9d365a72da37",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/get_process_info_linux.c"
                },
                "region": {
                  "startLine": 75,
                  "startColumn": 12,
                  "endLine": 75,
                  "endColumn": 31,
                  "charOffset": 2068,
                  "charLength": 19,
                  "snippet": {
                    "text": "malloc(size_buffer)",
                    "rendered": {
                      "text": "malloc(size_buffer)",
                      "markdown": "`malloc(size_buffer)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/get_process_info_linux.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2068,
                        "charLength": 19
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-97222dca-1e7f-41d2-8146-c8074933c35b",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/get_process_info_linux.c"
                },
                "region": {
                  "startLine": 57,
                  "startColumn": 2,
                  "endLine": 57,
                  "endColumn": 47,
                  "charOffset": 1607,
                  "charLength": 45,
                  "snippet": {
                    "text": "strncpy(*buffer, user_info->pw_name, namelen)",
                    "rendered": {
                      "text": "strncpy(*buffer, user_info->pw_name, namelen)",
                      "markdown": "`strncpy(*buffer, user_info->pw_name, namelen)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/get_process_info_linux.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1607,
                        "charLength": 45
                      },
                      "insertedContent": {
                        "text": "strcpy_s(*buffer,  namelen,  user_info->pw_name)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/get_process_info_linux.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1607,
                        "charLength": 45
                      },
                      "insertedContent": {
                        "text": "strlcpy(*buffer,  user_info->pw_name,  namelen)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-3b86d226-b7e4-4f61-b4e2-45d7ddb22ed5",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/get_process_info_linux.c"
                },
                "region": {
                  "startLine": 55,
                  "startColumn": 12,
                  "endLine": 55,
                  "endColumn": 45,
                  "charOffset": 1568,
                  "charLength": 33,
                  "snippet": {
                    "text": "malloc(namelen * sizeof(**buffer)",
                    "rendered": {
                      "text": "malloc(namelen * sizeof(**buffer)",
                      "markdown": "`malloc(namelen * sizeof(**buffer)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/get_process_info_linux.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1568,
                        "charLength": 33
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-2988c718-c634-415a-a525-7635fec1729f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/get_process_info_linux.c"
                },
                "region": {
                  "startLine": 54,
                  "startColumn": 19,
                  "endLine": 54,
                  "endColumn": 45,
                  "charOffset": 1524,
                  "charLength": 26,
                  "snippet": {
                    "text": "strlen(user_info->pw_name)",
                    "rendered": {
                      "text": "strlen(user_info->pw_name)",
                      "markdown": "`strlen(user_info->pw_name)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/get_process_info_linux.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1524,
                        "charLength": 26
                      },
                      "insertedContent": {
                        "text": "strlen_s(user_info->pw_name, <size of user_info->pw_name>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/get_process_info_linux.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1524,
                        "charLength": 26
                      },
                      "insertedContent": {
                        "text": "strnlen(user_info->pw_name, <size of user_info->pw_name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-0a212daf-5943-4576-aff0-0116867e9430",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/extract_gpuinfo_panthor.c"
                },
                "region": {
                  "startLine": 146,
                  "startColumn": 11,
                  "endLine": 146,
                  "endColumn": 84,
                  "charOffset": 5795,
                  "charLength": 73,
                  "snippet": {
                    "text": "strncpy(static_info->device_name, name, sizeof(static_info->device_name))",
                    "rendered": {
                      "text": "strncpy(static_info->device_name, name, sizeof(static_info->device_name))",
                      "markdown": "`strncpy(static_info->device_name, name, sizeof(static_info->device_name))`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_panthor.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5795,
                        "charLength": 73
                      },
                      "insertedContent": {
                        "text": "strcpy_s(static_info->device_name,  sizeof(static_info->device_name,  name)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_panthor.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5795,
                        "charLength": 73
                      },
                      "insertedContent": {
                        "text": "strlcpy(static_info->device_name,  name,  sizeof(static_info->device_name)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-1ab35a6b-7d57-440b-bdbd-4e062b5dd780",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "include/uthash.h"
                },
                "region": {
                  "startLine": 76,
                  "startColumn": 26,
                  "endLine": 76,
                  "endColumn": 36,
                  "charOffset": 3249,
                  "charLength": 10,
                  "snippet": {
                    "text": "malloc(sz)",
                    "rendered": {
                      "text": "malloc(sz)",
                      "markdown": "`malloc(sz)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/uthash.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3249,
                        "charLength": 10
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-5741fb3e-aa30-4758-b9a1-2bc6eb5ddd3b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "include/uthash.h"
                },
                "region": {
                  "startLine": 85,
                  "startColumn": 25,
                  "endLine": 85,
                  "endColumn": 34,
                  "charOffset": 3535,
                  "charLength": 9,
                  "snippet": {
                    "text": "strlen(s)",
                    "rendered": {
                      "text": "strlen(s)",
                      "markdown": "`strlen(s)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/uthash.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3535,
                        "charLength": 9
                      },
                      "insertedContent": {
                        "text": "strlen_s(s, <size of s>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "include/uthash.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3535,
                        "charLength": 9
                      },
                      "insertedContent": {
                        "text": "strnlen(s, <size of s>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-72e4ccde-05e8-454f-8e45-5f9218de123b",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncat)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/extract_gpuinfo_v3d_utils.c"
                },
                "region": {
                  "startLine": 113,
                  "startColumn": 2,
                  "endLine": 113,
                  "endColumn": 57,
                  "charOffset": 3438,
                  "charLength": 55,
                  "snippet": {
                    "text": "strncat(result, (const char *)(p + 6), available_space)",
                    "rendered": {
                      "text": "strncat(result, (const char *)(p + 6), available_space)",
                      "markdown": "`strncat(result, (const char *)(p + 6), available_space)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncat adds the null terminator at character 'n + 1', rather than at the nth character. this frequently leads to the null terminator being added in the memory adjacent to the destination buffer, rather than in the destination buffer."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_v3d_utils.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3438,
                        "charLength": 55
                      },
                      "insertedContent": {
                        "text": "strcat_s(result,  available_space,  (const char *)(p + 6))"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncat adds the null terminator at character 'n + 1', rather than at the nth character. this frequently leads to the null terminator being added in the memory adjacent to the destination buffer, rather than in the destination buffer."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_v3d_utils.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3438,
                        "charLength": 55
                      },
                      "insertedContent": {
                        "text": "strlcat(result,  (const char *)(p + 6),  available_space)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c95d18ac-204a-4b01-b1e2-4875795b48dc",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/extract_gpuinfo_v3d_utils.c"
                },
                "region": {
                  "startLine": 112,
                  "startColumn": 40,
                  "endLine": 112,
                  "endColumn": 54,
                  "charOffset": 3416,
                  "charLength": 14,
                  "snippet": {
                    "text": "strlen(result)",
                    "rendered": {
                      "text": "strlen(result)",
                      "markdown": "`strlen(result)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_v3d_utils.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3416,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strlen_s(result, <size of result>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_v3d_utils.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3416,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strnlen(result, <size of result>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-1b921f17-31e4-441c-872b-8b381b71db5f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/extract_gpuinfo_v3d_utils.c"
                },
                "region": {
                  "startLine": 103,
                  "startColumn": 2,
                  "endLine": 103,
                  "endColumn": 33,
                  "charOffset": 3201,
                  "charLength": 31,
                  "snippet": {
                    "text": "memcpy(p + i, command, len + 1)",
                    "rendered": {
                      "text": "memcpy(p + i, command, len + 1)",
                      "markdown": "`memcpy(p + i, command, len + 1)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_v3d_utils.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3201,
                        "charLength": 31
                      },
                      "insertedContent": {
                        "text": "memcpy_s(p + i, <size of p + i>,  command,  len + 1)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-7d98af15-d92a-4327-9db6-13cab2fdcf27",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/extract_gpuinfo_v3d_utils.c"
                },
                "region": {
                  "startLine": 89,
                  "startColumn": 12,
                  "endLine": 89,
                  "endColumn": 27,
                  "charOffset": 2746,
                  "charLength": 15,
                  "snippet": {
                    "text": "strlen(command)",
                    "rendered": {
                      "text": "strlen(command)",
                      "markdown": "`strlen(command)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_v3d_utils.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2746,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strlen_s(command, <size of command>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_v3d_utils.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2746,
                        "charLength": 15
                      },
                      "insertedContent": {
                        "text": "strnlen(command, <size of command>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-1c726f04-939c-4885-89b7-586cfc5ca5f0",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/interface_options.c"
                },
                "region": {
                  "startLine": 379,
                  "startColumn": 2,
                  "endLine": 379,
                  "endColumn": 52,
                  "charOffset": 15216,
                  "charLength": 50,
                  "snippet": {
                    "text": "strcpy(folder_path, options->config_file_location)",
                    "rendered": {
                      "text": "strcpy(folder_path, options->config_file_location)",
                      "markdown": "`strcpy(folder_path, options->config_file_location)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface_options.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 15216,
                        "charLength": 50
                      },
                      "insertedContent": {
                        "text": "strcpy_s(folder_path, <size of folder_path>,  options->config_file_location)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface_options.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 15216,
                        "charLength": 50
                      },
                      "insertedContent": {
                        "text": "strlcpy(folder_path,  options->config_file_location, <size of folder_path>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-fa4699cc-e59d-4acb-ada6-b977ef74203a",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/interface_options.c"
                },
                "region": {
                  "startLine": 147,
                  "startColumn": 6,
                  "endLine": 147,
                  "endColumn": 57,
                  "charOffset": 5775,
                  "charLength": 51,
                  "snippet": {
                    "text": "strcpy(options->config_file_location, default_path)",
                    "rendered": {
                      "text": "strcpy(options->config_file_location, default_path)",
                      "markdown": "`strcpy(options->config_file_location, default_path)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface_options.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5775,
                        "charLength": 51
                      },
                      "insertedContent": {
                        "text": "strcpy_s(options->config_file_location, <size of options->config_file_location>,  default_path)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface_options.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5775,
                        "charLength": 51
                      },
                      "insertedContent": {
                        "text": "strlcpy(options->config_file_location,  default_path, <size of options->config_file_location>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-d7d8c7be-8cd0-46c6-891c-a1be8d80ee8f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/interface_options.c"
                },
                "region": {
                  "startLine": 142,
                  "startColumn": 45,
                  "endLine": 142,
                  "endColumn": 65,
                  "charOffset": 5632,
                  "charLength": 20,
                  "snippet": {
                    "text": "strlen(default_path)",
                    "rendered": {
                      "text": "strlen(default_path)",
                      "markdown": "`strlen(default_path)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface_options.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5632,
                        "charLength": 20
                      },
                      "insertedContent": {
                        "text": "strlen_s(default_path, <size of default_path>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface_options.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5632,
                        "charLength": 20
                      },
                      "insertedContent": {
                        "text": "strnlen(default_path, <size of default_path>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-9d19b7aa-a1d9-4deb-8a3d-0ea1ad73596a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/interface_options.c"
                },
                "region": {
                  "startLine": 142,
                  "startColumn": 38,
                  "endLine": 142,
                  "endColumn": 65,
                  "charOffset": 5625,
                  "charLength": 27,
                  "snippet": {
                    "text": "malloc(strlen(default_path)",
                    "rendered": {
                      "text": "malloc(strlen(default_path)",
                      "markdown": "`malloc(strlen(default_path)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface_options.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5625,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-093f0add-3065-460b-b194-eac7dbe1b623",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/interface_options.c"
                },
                "region": {
                  "startLine": 138,
                  "startColumn": 4,
                  "endLine": 138,
                  "endColumn": 58,
                  "charOffset": 5442,
                  "charLength": 54,
                  "snippet": {
                    "text": "strcpy(options->config_file_location, config_location)",
                    "rendered": {
                      "text": "strcpy(options->config_file_location, config_location)",
                      "markdown": "`strcpy(options->config_file_location, config_location)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface_options.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5442,
                        "charLength": 54
                      },
                      "insertedContent": {
                        "text": "strcpy_s(options->config_file_location, <size of options->config_file_location>,  config_location)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface_options.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5442,
                        "charLength": 54
                      },
                      "insertedContent": {
                        "text": "strlcpy(options->config_file_location,  config_location, <size of options->config_file_location>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-bb6e4955-7601-4e6a-ae59-6af4e72de5ce",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/interface_options.c"
                },
                "region": {
                  "startLine": 133,
                  "startColumn": 43,
                  "endLine": 133,
                  "endColumn": 66,
                  "charOffset": 5292,
                  "charLength": 23,
                  "snippet": {
                    "text": "strlen(config_location)",
                    "rendered": {
                      "text": "strlen(config_location)",
                      "markdown": "`strlen(config_location)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface_options.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5292,
                        "charLength": 23
                      },
                      "insertedContent": {
                        "text": "strlen_s(config_location, <size of config_location>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface_options.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5292,
                        "charLength": 23
                      },
                      "insertedContent": {
                        "text": "strnlen(config_location, <size of config_location>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-4c242e06-154e-48c6-b0f7-1463ee41e9b0",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/interface_options.c"
                },
                "region": {
                  "startLine": 133,
                  "startColumn": 36,
                  "endLine": 133,
                  "endColumn": 66,
                  "charOffset": 5285,
                  "charLength": 30,
                  "snippet": {
                    "text": "malloc(strlen(config_location)",
                    "rendered": {
                      "text": "malloc(strlen(config_location)",
                      "markdown": "`malloc(strlen(config_location)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface_options.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5285,
                        "charLength": 30
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-4688b6c6-940f-4951-8ed4-780cdd68ead4",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/interface_options.c"
                },
                "region": {
                  "startLine": 58,
                  "startColumn": 4,
                  "endLine": 58,
                  "endColumn": 91,
                  "charOffset": 1931,
                  "charLength": 87,
                  "snippet": {
                    "text": "strcpy(config_file_path + xdg_path_length + 1 + conf_path_length, config_file_location)",
                    "rendered": {
                      "text": "strcpy(config_file_path + xdg_path_length + 1 + conf_path_length, config_file_location)",
                      "markdown": "`strcpy(config_file_path + xdg_path_length + 1 + conf_path_length, config_file_location)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface_options.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1931,
                        "charLength": 87
                      },
                      "insertedContent": {
                        "text": "strcpy_s(config_file_path + xdg_path_length + 1 + conf_path_length, <size of config_file_path + xdg_path_length + 1 + conf_path_length>,  config_file_location)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface_options.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1931,
                        "charLength": 87
                      },
                      "insertedContent": {
                        "text": "strlcpy(config_file_path + xdg_path_length + 1 + conf_path_length,  config_file_location, <size of config_file_path + xdg_path_length + 1 + conf_path_length>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-d124129b-26b5-49be-aba7-16a79401e46d",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/interface_options.c"
                },
                "region": {
                  "startLine": 55,
                  "startColumn": 6,
                  "endLine": 55,
                  "endColumn": 70,
                  "charOffset": 1789,
                  "charLength": 64,
                  "snippet": {
                    "text": "strcpy(config_file_path + xdg_path_length + 1, config_conf_path)",
                    "rendered": {
                      "text": "strcpy(config_file_path + xdg_path_length + 1, config_conf_path)",
                      "markdown": "`strcpy(config_file_path + xdg_path_length + 1, config_conf_path)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface_options.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1789,
                        "charLength": 64
                      },
                      "insertedContent": {
                        "text": "strcpy_s(config_file_path + xdg_path_length + 1, <size of config_file_path + xdg_path_length + 1>,  config_conf_path)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface_options.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1789,
                        "charLength": 64
                      },
                      "insertedContent": {
                        "text": "strlcpy(config_file_path + xdg_path_length + 1,  config_conf_path, <size of config_file_path + xdg_path_length + 1>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-54aa5ce7-c83e-4785-a305-8607f6413a0d",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/interface_options.c"
                },
                "region": {
                  "startLine": 52,
                  "startColumn": 4,
                  "endLine": 52,
                  "endColumn": 44,
                  "charOffset": 1668,
                  "charLength": 40,
                  "snippet": {
                    "text": "strcpy(config_file_path, xdg_config_dir)",
                    "rendered": {
                      "text": "strcpy(config_file_path, xdg_config_dir)",
                      "markdown": "`strcpy(config_file_path, xdg_config_dir)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface_options.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1668,
                        "charLength": 40
                      },
                      "insertedContent": {
                        "text": "strcpy_s(config_file_path, <size of config_file_path>,  xdg_config_dir)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface_options.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1668,
                        "charLength": 40
                      },
                      "insertedContent": {
                        "text": "strlcpy(config_file_path,  xdg_config_dir, <size of config_file_path>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-3c7efcaa-a661-4a91-bf88-b44efdf4c810",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/interface_options.c"
                },
                "region": {
                  "startLine": 50,
                  "startColumn": 27,
                  "endLine": 50,
                  "endColumn": 49,
                  "charOffset": 1554,
                  "charLength": 22,
                  "snippet": {
                    "text": "strlen(xdg_config_dir)",
                    "rendered": {
                      "text": "strlen(xdg_config_dir)",
                      "markdown": "`strlen(xdg_config_dir)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface_options.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1554,
                        "charLength": 22
                      },
                      "insertedContent": {
                        "text": "strlen_s(xdg_config_dir, <size of xdg_config_dir>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface_options.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1554,
                        "charLength": 22
                      },
                      "insertedContent": {
                        "text": "strnlen(xdg_config_dir, <size of xdg_config_dir>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f31e7c04-f293-4c0d-abad-6909e67cef96",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/extract_gpuinfo_tpu.c"
                },
                "region": {
                  "startLine": 293,
                  "startColumn": 48,
                  "endLine": 293,
                  "endColumn": 85,
                  "charOffset": 10399,
                  "charLength": 37,
                  "snippet": {
                    "text": "malloc(1 * sizeof(struct gpu_process)",
                    "rendered": {
                      "text": "malloc(1 * sizeof(struct gpu_process)",
                      "markdown": "`malloc(1 * sizeof(struct gpu_process)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_tpu.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10399,
                        "charLength": 37
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e0b85f70-c914-4c60-a756-ef3ce91cd0dd",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/extract_gpuinfo_tpu.c"
                },
                "region": {
                  "startLine": 205,
                  "startColumn": 29,
                  "endLine": 205,
                  "endColumn": 50,
                  "charOffset": 6933,
                  "charLength": 21,
                  "snippet": {
                    "text": "malloc(sizeof(double)",
                    "rendered": {
                      "text": "malloc(sizeof(double)",
                      "markdown": "`malloc(sizeof(double)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_tpu.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6933,
                        "charLength": 21
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c82429e0-cd04-4fe5-803f-808d8b3a43c9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/extract_gpuinfo_tpu.c"
                },
                "region": {
                  "startLine": 203,
                  "startColumn": 26,
                  "endLine": 203,
                  "endColumn": 46,
                  "charOffset": 6798,
                  "charLength": 20,
                  "snippet": {
                    "text": "malloc(sizeof(int64)",
                    "rendered": {
                      "text": "malloc(sizeof(int64)",
                      "markdown": "`malloc(sizeof(int64)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_tpu.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6798,
                        "charLength": 20
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-30ee7978-73cc-4caa-a40f-1d27ae8b4df4",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/extract_gpuinfo_tpu.c"
                },
                "region": {
                  "startLine": 204,
                  "startColumn": 26,
                  "endLine": 204,
                  "endColumn": 46,
                  "charOffset": 6864,
                  "charLength": 20,
                  "snippet": {
                    "text": "malloc(sizeof(int64)",
                    "rendered": {
                      "text": "malloc(sizeof(int64)",
                      "markdown": "`malloc(sizeof(int64)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_tpu.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6864,
                        "charLength": 20
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b592aa2f-2b98-453c-aaa0-362563edcf2c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/extract_gpuinfo_tpu.c"
                },
                "region": {
                  "startLine": 202,
                  "startColumn": 24,
                  "endLine": 202,
                  "endColumn": 44,
                  "charOffset": 6732,
                  "charLength": 20,
                  "snippet": {
                    "text": "malloc(sizeof(int64)",
                    "rendered": {
                      "text": "malloc(sizeof(int64)",
                      "markdown": "`malloc(sizeof(int64)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_tpu.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6732,
                        "charLength": 20
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-742d1227-ee59-4510-bd7c-666d0660371b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/extract_gpuinfo_tpu.c"
                },
                "region": {
                  "startLine": 201,
                  "startColumn": 18,
                  "endLine": 201,
                  "endColumn": 38,
                  "charOffset": 6668,
                  "charLength": 20,
                  "snippet": {
                    "text": "malloc(sizeof(int64)",
                    "rendered": {
                      "text": "malloc(sizeof(int64)",
                      "markdown": "`malloc(sizeof(int64)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_tpu.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6668,
                        "charLength": 20
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-529402e5-fd3d-4828-b9b3-bad2d59a1750",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/extract_gpuinfo_tpu.c"
                },
                "region": {
                  "startLine": 200,
                  "startColumn": 57,
                  "endLine": 200,
                  "endColumn": 113,
                  "charOffset": 6591,
                  "charLength": 56,
                  "snippet": {
                    "text": "malloc(tpu_chip_count*sizeof(struct tpu_chip_usage_data)",
                    "rendered": {
                      "text": "malloc(tpu_chip_count*sizeof(struct tpu_chip_usage_data)",
                      "markdown": "`malloc(tpu_chip_count*sizeof(struct tpu_chip_usage_data)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_tpu.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6591,
                        "charLength": 56
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-25f53dbe-1a9e-49c2-b1c2-47bf2108b7f1",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/extract_gpuinfo_nvidia.c"
                },
                "region": {
                  "startLine": 693,
                  "startColumn": 46,
                  "endLine": 693,
                  "endColumn": 85,
                  "charOffset": 29403,
                  "charLength": 39,
                  "snippet": {
                    "text": "malloc(samples_count * sizeof(*samples)",
                    "rendered": {
                      "text": "malloc(samples_count * sizeof(*samples)",
                      "markdown": "`malloc(samples_count * sizeof(*samples)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_nvidia.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 29403,
                        "charLength": 39
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-fad0862b-e262-4748-b98d-2792c8f9c025",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/extract_gpuinfo_nvidia.c"
                },
                "region": {
                  "startLine": 499,
                  "startColumn": 8,
                  "endLine": 499,
                  "endColumn": 75,
                  "charOffset": 20419,
                  "charLength": 67,
                  "snippet": {
                    "text": "strncpy(gpu_infos[*count].base.pdev, pciInfo.busIdLegacy, PDEV_LEN)",
                    "rendered": {
                      "text": "strncpy(gpu_infos[*count].base.pdev, pciInfo.busIdLegacy, PDEV_LEN)",
                      "markdown": "`strncpy(gpu_infos[*count].base.pdev, pciInfo.busIdLegacy, PDEV_LEN)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_nvidia.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 20419,
                        "charLength": 67
                      },
                      "insertedContent": {
                        "text": "strcpy_s(gpu_infos[*count].base.pdev,  PDEV_LEN,  pciInfo.busIdLegacy)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_nvidia.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 20419,
                        "charLength": 67
                      },
                      "insertedContent": {
                        "text": "strlcpy(gpu_infos[*count].base.pdev,  pciInfo.busIdLegacy,  PDEV_LEN)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-d921e84a-7d3b-44c6-a5dd-7eaead261213",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/extract_gpuinfo_ascend.c"
                },
                "region": {
                  "startLine": 233,
                  "startColumn": 41,
                  "endLine": 233,
                  "endColumn": 96,
                  "charOffset": 9019,
                  "charLength": 55,
                  "snippet": {
                    "text": "malloc(MAX_PROC_NUM * sizeof(struct dcmi_proc_mem_info)",
                    "rendered": {
                      "text": "malloc(MAX_PROC_NUM * sizeof(struct dcmi_proc_mem_info)",
                      "markdown": "`malloc(MAX_PROC_NUM * sizeof(struct dcmi_proc_mem_info)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_ascend.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 9019,
                        "charLength": 55
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-1a5a06e1-7478-4200-b7fa-64cc7ae855dd",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strncpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/extract_gpuinfo_ascend.c"
                },
                "region": {
                  "startLine": 162,
                  "startColumn": 4,
                  "endLine": 162,
                  "endColumn": 88,
                  "charOffset": 5745,
                  "charLength": 84,
                  "snippet": {
                    "text": "strncpy(static_info->device_name, (char*) chip_info->chip_name, MAX_DEVICE_NAME - 1)",
                    "rendered": {
                      "text": "strncpy(static_info->device_name, (char*) chip_info->chip_name, MAX_DEVICE_NAME - 1)",
                      "markdown": "`strncpy(static_info->device_name, (char*) chip_info->chip_name, MAX_DEVICE_NAME - 1)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_ascend.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5745,
                        "charLength": 84
                      },
                      "insertedContent": {
                        "text": "strcpy_s(static_info->device_name,  MAX_DEVICE_NAME - 1,  (char*) chip_info->chip_name)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_ascend.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5745,
                        "charLength": 84
                      },
                      "insertedContent": {
                        "text": "strlcpy(static_info->device_name,  (char*) chip_info->chip_name,  MAX_DEVICE_NAME - 1)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-dc4b70c6-b119-49a1-9c71-e2cb79a496df",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ini.c"
                },
                "region": {
                  "startLine": 282,
                  "startColumn": 17,
                  "endLine": 282,
                  "endColumn": 31,
                  "charOffset": 7237,
                  "charLength": 14,
                  "snippet": {
                    "text": "strlen(string)",
                    "rendered": {
                      "text": "strlen(string)",
                      "markdown": "`strlen(string)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ini.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7237,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strlen_s(string, <size of string>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ini.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7237,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strnlen(string, <size of string>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-0b9bda85-04df-42bd-8d00-e7cf61d19b76",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ini.c"
                },
                "region": {
                  "startLine": 146,
                  "startColumn": 16,
                  "endLine": 146,
                  "endColumn": 37,
                  "charOffset": 3723,
                  "charLength": 21,
                  "snippet": {
                    "text": "strlen(line + offset)",
                    "rendered": {
                      "text": "strlen(line + offset)",
                      "markdown": "`strlen(line + offset)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ini.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3723,
                        "charLength": 21
                      },
                      "insertedContent": {
                        "text": "strlen_s(line + offset, <size of line + offset>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ini.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3723,
                        "charLength": 21
                      },
                      "insertedContent": {
                        "text": "strnlen(line + offset, <size of line + offset>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-00626b4f-248a-4490-99ef-5b60da97006e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ini.c"
                },
                "region": {
                  "startLine": 49,
                  "startColumn": 16,
                  "endLine": 49,
                  "endColumn": 25,
                  "charOffset": 1027,
                  "charLength": 9,
                  "snippet": {
                    "text": "strlen(s)",
                    "rendered": {
                      "text": "strlen(s)",
                      "markdown": "`strlen(s)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ini.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1027,
                        "charLength": 9
                      },
                      "insertedContent": {
                        "text": "strlen_s(s, <size of s>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ini.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1027,
                        "charLength": 9
                      },
                      "insertedContent": {
                        "text": "strnlen(s, <size of s>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-42cfa7bb-a143-4afc-83a3-d61c0c693f27",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/ini.c"
                },
                "region": {
                  "startLine": 131,
                  "startColumn": 13,
                  "endLine": 131,
                  "endColumn": 25,
                  "charOffset": 3255,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(line)",
                    "rendered": {
                      "text": "strlen(line)",
                      "markdown": "`strlen(line)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ini.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3255,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(line, <size of line>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/ini.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3255,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(line, <size of line>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-39351bba-d8c3-424d-a5ec-2bca2ead551a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/extract_gpuinfo_ascend.c"
                },
                "region": {
                  "startLine": 157,
                  "startColumn": 37,
                  "endLine": 157,
                  "endColumn": 73,
                  "charOffset": 5454,
                  "charLength": 36,
                  "snippet": {
                    "text": "malloc(sizeof(struct dcmi_chip_info)",
                    "rendered": {
                      "text": "malloc(sizeof(struct dcmi_chip_info)",
                      "markdown": "`malloc(sizeof(struct dcmi_chip_info)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_ascend.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5454,
                        "charLength": 36
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}